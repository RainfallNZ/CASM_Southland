---
title: "R Notebook to preprocess water quality data for use with CASM, for Horizons"
output: html_notebook
---

load some libraries
```{r}
if (!require(rgdal)) install.packages("rgdal"); library(rgdal)                #used for spatial processing
if (!require(ggplot2)) install.packages("ggplot2"); library(ggplot2)                #used for plotting
if (!require(gridExtra)) install.packages("gridExtra"); library(gridExtra)                #Used for plotting multiple plots to output
if (!require(plyr)) install.packages("plyr"); library(plyr)                #used for the join function
if (!require(knitr)) install.packages("knitr"); library(knitr)                #used to make nice looking tables
if (!require(rgeos)) install.packages("rgeos"); library(rgeos)                #used for spatial processing
if (!require(raster)) install.packages("raster"); library(raster)                #used for spatial processing
if (!require(leaflet)) install.packages("leaflet"); library(leaflet)                #used for spatial processing
if (!require(rmapshaper)) install.packages("rmapshaper"); library(rmapshaper)                #used for spatial processing
if (!require(devtools)) install.packages("devtools"); library(devtools)                #Needed to load libraries from github
if (!require(tictoc)) install.packages("tictoc"); library(tictoc)                         #used for timing processing
if (!require(CASMPrePostProcessor)) install_github("rainfallnz/CASMPrePostProcessor"); library(CASMPrePostProcessor)                #Needed to load libraries from github

```


Set directories and data file names
```{r}
#Set the project directory
ProjectDirectory <- "D:\\Projects\\LWP\\SouthlandRegionalForumModelling"       #Tim Kerr's Windows Home laptop

#Set the data directory
DataDirectory     <- file.path(ProjectDirectory, "Data")

#Set the GIS directory
GISDataDirectory  <- file.path(DataDirectory,"GIS")

#Set some R data filenames from the LWP data store
REC_MeanFlowFile <- file.path(DataDirectory,"REC2MeanFlow.RData")  #This is an RData file
REC2UtilityFile <- file.path(DataDirectory,"REC2Utility.rdata")  #This contains a dataframe called REC2Utility, which has a whole bunch of REC2 attributes, including river names
REC2UtilityExtraFile <- file.path(DataDirectory,"FINAL_REC2_FOR_PREDICTIONS.Rdata")  #This contains a dataframe called REC2, which has a whole bunch of additional REC2 attributes, 

#Set the names of the shapefile spatial data in ESRI format
#REC data is available from the MfE data service. See https://data.mfe.govt.nz/layer/51826-river-environment-classification-manawatu-2010/ and https://data.mfe.govt.nz/layer/51847-river-environment-classification-watershed-manawatu-2010/

REC_rivers              <- "ES_REC2V5_Riverlines"
#Or an REC3 version
#REC_rivers             <- "ES_REC3_Riverlines"
#REC_Catchments         <- "ESWaterShedsWithPlanClasses" #An ESRI polygon shape file with Environment Southland Plan Classses

#WaterQualityStationFile <- "WaterQualitySites" #A Point shape file
#LakeSiteFile            <- "LakeSites"  #A Point shape file
LakePolygonFile         <- "NZLRIClip_Lakes" #A polygon shape file

ExtraCASMNodeSiteFile   <- "ExtraCASMNodes"  #A Point Shape File
RiverOutletsFile        <- "RiverMouthSites" #A Point Shape File

MajorCatchmentsFile     <- "FactsheetZoneAreas"   #A polygon shapefile
GroundwaterZonesFile    <- "Environment_Southland_Groundwater_Management_Zones_RWP_2010" #AI polygon shapefile
PhysiographicDataFile   <- "Environment_Southland_Physiographic_Zones" #A polygon shapefile
WaterPlanClassificationFile <- "WaterPlanClassification" #A Shape file

LanduseShapeFile        <- file.path(GISDataDirectory,"LanduseLayers/LandUse2017/LandUse2017.shp")
SoilDrainageShapeFile   <- file.path(GISDataDirectory,"LanduseLayers/Soil_drainage/Soil_drainage.shp")
SlopeClassShapeFile     <- file.path(GISDataDirectory,"LanduseLayers/LRI_Slope_Layer/LRI_Slope_Layer.shp")
PrecipIrrigShapeFile    <- file.path(GISDataDirectory,"LanduseLayers/PrecipitationClass_withIrri/PrecipitationClass_withIrri.shp")


#Set the name of raster file data in geoTiff format
WaterPlanClassificationRasterFile <- file.path(GISDataDirectory,"ES_PlanClassification.tif") #A raster file
LeachRateRasterFile     <- file.path(GISDataDirectory,"LeachRateRaster 250 x 250.tif")
PredictorRasterFile     <- file.path(GISDataDirectory,"PredictorRaster 250 x 250.tif")

#Set the names of some text tables in csv format
LakeSiteFile            <- file.path(DataDirectory,"Lakes_ToIncludeAsAssessmentPoints.csv")
WaterQualityStationFile <- file.path(DataDirectory,"RWQSiteList_IncludingAddtional5.csv")
#OutletReachNamesFile   <- "OutletReachNames.csv"
EstuarySiteFile         <- "Estuaries.csv"
#NZsegmentToWaterPlanClassLookUpTableFile <-  file.path(DataDirectory,"NZsegmentToWaterPlan.csv")
NZsegmentToWaterPlanClassLookUpTableFile <-  file.path(DataDirectory,"REC2WaterPlanV1.csv")
UnnecesaryAssessmentSitesFile <-  file.path(DataDirectory,"SubcatchmentJunctionSitesNotRequired.csv")
PointSourceSitesFile    <- file.path(DataDirectory,"SldPointSourceLoadsNZSegmentAssigned.csv")

#Set the names of some Excel workbooks
LeachRateLUTFile        <- file.path(DataDirectory,"Losses Lookup Table - DRAFT.xlsx")


```


load data
```{r}
#Load the major catchments
MajorCatchments <- readOGR(dsn =file.path(GISDataDirectory),
                           layer = MajorCatchmentsFile, stringsAsFactors = FALSE)
MajorCatchments <- spTransform(MajorCatchments,CRS("+init=epsg:2193") )
#Ditch Fiordland and Stewart Island
MajorCatchments <- MajorCatchments[-which(MajorCatchments$FactSheetZ %in% c("Fiordland","Stewart Island/ Rakiura Zone","Coastal Islands")),]
#Ditch the NA catchemnts
MajorCatchments <- MajorCatchments[!is.na(MajorCatchments$FactSheetZ),]
MajorCatchments <- ms_simplify(MajorCatchments)
projection(MajorCatchments) <- CRS("+init=epsg:2193")   #re-assign the NZTM specific projection as it gets dropped by the ms_simplify function.

#Create a full domain (with help to clean it from https://stackoverflow.com/questions/12663263/dissolve-holes-in-polygon-in-r )
CompleteDomain <- gUnaryUnion(MajorCatchments)
outerRings = Filter(function(f){f@ringDir==1},CompleteDomain@polygons[[1]]@Polygons)
CompleteDomain = SpatialPolygons(list(Polygons(outerRings,ID=1)))
crs(CompleteDomain) <- crs(MajorCatchments)

#Load the lookup table between REC2 nzsegment and Environment Southland's Water Plan class
NZsegmentToWaterPlanClassLookUpTable <- read.table(NZsegmentToWaterPlanClassLookUpTableFile, sep=",", stringsAsFactors = FALSE,header = TRUE)

#If the lookup table is not available then it can be recreated using the code immediately below
# {
# #Read in the REC riverlines that have been converted to points
# REC2RiverLinePOints <- readOGR(dsn = GISDataDirectory,layer = "ES_REC2_Riverline_Vertices_WaterPlan")
# 
# REC2RiverlinePointData <- REC2RiverLinePOints@data
# rm(REC2RiverLinePOints) #to free up memory
# 
# #Aggregate on NZSegment, returning the majority of WaterPlan
# REC2ToWaterPlanLUT <- aggregate(REC2RiverlinePointData$WaterPlan,list(REC2RiverlinePointData$nzsegment),FUN= modal)
# names(REC2ToWaterPlanLUT) <- c("nzsegment","Number")
# REC2ToWaterPlanLUT$Name <-   c("Hills", "Lakes", "Lowland Hardbed", "Lowland Softbed", "Mountain", "Natural State")[REC2ToWaterPlanLUT$Number]
# 
# #Export as a csv file
# write.table(REC2ToWaterPlanLUT,file=file.path(DataDirectory,NZsegmentToWaterPlanClassLookUpTableFile), sep=",",row.names = FALSE)
# }

#REC data has been sourced from LWP data stores. It has cut down versions of the attribute names, e.g. nzsegment is nzsgmnt. Keep an eye on this when comparing to other data sources that may have the full RECV2 attribute names.
RECReachNetwork <- readOGR(dsn =file.path(GISDataDirectory,REC_rivers),
                           layer = REC_rivers, stringsAsFactors = FALSE)

RECReachNetwork <- spTransform(RECReachNetwork,CRS("+init=epsg:2193") )
#Explicitly set the "headw_dist","nzsegment","headw_dist","TO_NODE","FROM_NODE" attributes to numeric

RECReachNetwork@data[,c("headw_dist","nzsegment","TO_NODE","FROM_NODE")]<- lapply(RECReachNetwork@data[,c("headw_dist","nzsegment","TO_NODE","FROM_NODE")],as.numeric)
#Load the REC2 utility data with lots of useful stuff in it, including river names
load(REC2UtilityFile)   #This provides the REC2Utility data frame
#Cut it down to Southland
SouthlandREC2Utility <- REC2Utility[REC2Utility$Region == "S",]
rm(REC2Utility)

#Load the REC2 "Extra" utility data with lots more useful stuff in it, including upstream high producing exotic pasture (LCDB# Class 40)
load(REC2UtilityExtraFile)   #This provides a data frame called REC2
#Cut it down to Southland, and just the column of interest
SouthlandREC2ExtraUtility <- REC2[REC2$nzsegment %in% SouthlandREC2Utility$nzsegment,c("nzsegment","us_LCDB3_40")]
rm(REC2)
#rename the column to "UpstreamHighProducingExoticPasture"
names(SouthlandREC2ExtraUtility)[2] <- "UpstreamHighProducingExoticPasture"

SouthlandREC2Utility <- join(SouthlandREC2Utility,SouthlandREC2ExtraUtility, type="left")
#Calculate percentage upstream exotic pasture
SouthlandREC2Utility$pctExoticPasture <- SouthlandREC2Utility$UpstreamHighProducingExoticPasture / SouthlandREC2Utility$catAreaKM2 /10000
#Fix the five aberrant values 
SouthlandREC2Utility$pctExoticPasture[SouthlandREC2Utility$pctExoticPasture > 100] <- 100


# #For the REC3 network, need to change the name of some columns for compatibility with functions developed for RECV2
# #nzseg_v3 to nzsegment
# names(RECReachNetwork@data)[which(names(RECReachNetwork@data) == "nzseg_v3")] <- "nzsegment"
# #ups_length to headw_dist
# names(RECReachNetwork@data)[which(names(RECReachNetwork@data) == "ups_length")] <- "headw_dist"

# #For the REC3 network, need to make some columns numeric
# RECReachNetwork@data[,c("Order_","nzsegment","FROM_NODE","TO_NODE")] <- lapply(RECReachNetwork@data[,c("Order_","nzsegment","FROM_NODE","TO_NODE")],as.numeric)

##Add the Environment Southland Water Plan Class to the REC2 data
RECReachNetwork$WaterPlan <- NZsegmentToWaterPlanClassLookUpTable$WaterPlanV1[match(RECReachNetwork$nzsegment, NZsegmentToWaterPlanClassLookUpTable$nzsegment)]

#REstrict it to just the major catchments of interest
#RECReachNetwork <- gIntersection(RECReachNetwork,CompleteDomain,byid =TRUE)

#RECWatersheds <- readOGR(dsn = file.path(GISDataDirectory,REC_Catchments),
#                         layer = REC_Catchments)
#RECWatersheds <- spTransform(RECWatersheds,CRS("+init=epsg:2193") )

#Load the mean flow data for the REC V2. This is provided in an rdata file which contains the data frame REC2MeanFlow, with three columns, "nzsegment","QMean", and "us_catarea"
#load(REC_MeanFlowFile)

#Load the Southland water quality measurement site data and turn into a spatial data frame
MeasurementSites <- read.table(WaterQualityStationFile,sep=",",stringsAsFactors = FALSE, header=TRUE)
MeasurementSites <- SpatialPointsDataFrame(coords = MeasurementSites[,c("downcoordX","downcoordY")], data = MeasurementSites,
                               proj4string = CRS("+init=epsg:2193"))
#make sure the nzsegment attribute is numeric
MeasurementSites$nzsegment <- as.numeric(MeasurementSites$nzsegment)
#Remove any duplicate sites
MeasurementSites <- MeasurementSites[!duplicated(MeasurementSites$nzsegment),]

#Load lake sites of interest
LakeSites  <- read.table(LakeSiteFile,sep=",",stringsAsFactors = FALSE, header=TRUE)
LakeSites <- SpatialPointsDataFrame(coords = LakeSites[,c("downcoordX","downcoordY")], data = LakeSites,
                               proj4string = CRS("+init=epsg:2193"))
#make sure the nzsegment attribute is numeric
LakeSites$nzsegment <- as.numeric(LakeSites$nzsegment)
#Set the name of the un named lake to "un-named"
LakeSites@data$LakeName[LakeSites@data$LakeName==" "] <- "unnamed"


#Load the lake polygon layer
Lakes <- readOGR(dsn =file.path(GISDataDirectory,LakePolygonFile),layer = LakePolygonFile, stringsAsFactors = FALSE)
Lakes <- spTransform(Lakes,CRS("+init=epsg:2193") )

#Load the additional subjective site locations
ExtraSites <- readOGR(dsn =file.path(GISDataDirectory,ExtraCASMNodeSiteFile),
                           layer = ExtraCASMNodeSiteFile, stringsAsFactors = FALSE)
ExtraSites <- spTransform(ExtraSites,CRS("+init=epsg:2193") )
ExtraSites$nzsegment <- as.numeric(ExtraSites$nzsegment)

#Load a list of river segments where assessment points are NOT needed.
UnnecesaryAssessmentSites <- read.table(UnnecesaryAssessmentSitesFile,sep=",",stringsAsFactors = FALSE, header=TRUE)

#Load the additional river mouth site locations
RiverMouthSites <- readOGR(dsn =file.path(GISDataDirectory,RiverOutletsFile),
                           layer = RiverOutletsFile, stringsAsFactors = FALSE)
RiverMouthSites <- spTransform(RiverMouthSites,CRS("+init=epsg:2193") )

#Load the estuary site data
EstuarySites <- read.table(file.path(DataDirectory,EstuarySiteFile),header=TRUE,stringsAsFactors = FALSE, sep=",")
#Create a spatial file from it
EstuarySitesSpatial <- SpatialPointsDataFrame(coords = EstuarySites[,c("NZTME","NZTMN")],data = EstuarySites, proj4string = CRS("+init=epsg:2193"))

#Load the Environment Southland Water Plan Classification spatial data
#WaterPlanClassification <- readOGR(dsn = file.path(GISDataDirectory,WaterPlanClassificationFile), layer =WaterPlanClassificationFile, stringsAsFactors = FALSE)
#WaterPlanClassification <- spTransform(WaterPlanClassification,CRS("+init=epsg:2193") )

# #Load the Water Plan classification raster data
#   WaterPlanRaster <- raster(WaterPlanClassificationRasterFile)
#   
#   #reproject to WGS84 for mapping
#   WaterPlanRasterWGS84 <- projectRaster(WaterPlanRaster,crs = CRS("+init=epsg:4326"),method = "ngb")
#   WaterPlanRasterWGS84 <- ratify(WaterPlanRasterWGS84)
#   WaterPlanClassRAT <- levels(WaterPlanRasterWGS84)[[1]]
#   WaterPlanClassRAT$WaterPlanClass <- c("Hills", "Lakes", "Lowland Hardbed", "Lowland Softbed", "Mountain", "Natural State")
#   levels(WaterPlanRasterWGS84)  <- WaterPlanClassRAT

#Load the point source site data
PointSources <- read.csv(PointSourceSitesFile,stringsAsFactors = FALSE)
#Create a spatial file from it
PointSourcesSpatial <- SpatialPointsDataFrame(coords = PointSources[,c("Easting","Northing")],data = PointSources, proj4string = CRS("+init=epsg:2193"))

  #Load the Groundwater Management Zone data
GroundwaterZones <- readOGR(dsn =file.path(GISDataDirectory,GroundwaterZonesFile),
                           layer = GroundwaterZonesFile, stringsAsFactors = FALSE)
GroundwaterZones <- spTransform(GroundwaterZones,CRS("+init=epsg:2193") )

#Load the leachrate data if it exists
LeachRateRaster <- stack(LeachRateRasterFile)

#**********Need to select which leach rate we want. CUrrently have a choice of 4.

#**********************************************************
#If the leach rate raster file is missing or needs to be re-created then use the following:
#Takes 4 minutes at 250 m
# source(file.path(ProjectDirectory,"R/CASM_Southland/LeachRateRasterCreator.R"))
# tic()
# LeachRateRaster <- LeachRateRasterCreator(LanduseData=LanduseShapeFile,
#                                    SoilDrainageData=SoilDrainageShapeFile,
#                                    SlopeClassData=SlopeClassShapeFile,
#                                    PrecipIrrig=PrecipIrrigShapeFile,
#                                    LeachRateData = LeachRateLUTFile,
#                                    Resolution = 250)
# toc()
# #And save it for nexttime
# writeRaster(LeachRateRaster[[1:4]],LeachRateRasterFile,overwrite=TRUE)
# writeRaster(LeachRateRaster[[5:8]],PredictorRasterFile,overwrite=TRUE)

#******************************************************************

```


********************************
Load the Physiographic Zones data. This frequently has issues! Best to run it line by line
*******************************

```{r}
Physiography <- readOGR(dsn =file.path(GISDataDirectory,PhysiographicDataFile),
                           layer = PhysiographicDataFile)
Physiography <- spTransform(Physiography,CRS("+init=epsg:2193") )

#Convert to a raster with an attribute table, and  for mapping later on
  #Convert to raster, note the creation of a base raster in WGS84, which all subsequent raster's align to
  RasterBase <- raster(resolution = 250, ext = extent(MajorCatchments), crs = proj4string(MajorCatchments) )
  PhysiographyRaster <- rasterize(Physiography,RasterBase,"Physiograp")
  #Crop to the Complete domain, and then mask to the same
  PhysiographyRaster <- crop(PhysiographyRaster,extent(CompleteDomain))
  PhysiographyRaster <- mask(PhysiographyRaster, CompleteDomain)
  
  #Note, for the next line I have had issues with repeated errors of "Error in x$.self$finalize() : attempt to apply non-function"
  #I don't know the cause. It just goes away when I run the command again. Maybe it is doing stuff on the raster before the raster has been created.
  #A possible solution is to transform the vector to WGS84 straight up, rather than transform the raster. I might need to create a transformed version of complete domain as well.
  
  PhysiographyRasterWGS84 <- projectRaster(PhysiographyRaster,crs = CRS("+init=epsg:4326"),method = "ngb")
  PhysiographyRasterWGS84 <- ratify(PhysiographyRasterWGS84)
  PhysiographyRAT <- levels(PhysiographyRasterWGS84)[[1]]
  PhysiographyRAT$Physiography <- levels(Physiography$Physiograp)
  levels(PhysiographyRasterWGS84)  <- PhysiographyRAT



```
Identify the lowest reach in each subcatchment for Strahler order 4 and up, and create a point at its lowest node


Not sure if the following is needed anymore.
Get the "nzsegment" attributes of the lowest reach in each of the major catchments
```{r}
CatchmentReaches <- RECReachNetwork %over% MajorCatchments #Note this takes about a minute to do
RECReachNetwork$Catchment <- CatchmentReaches$FactSheetZ

#Work through each management zone to find the reach with the greatest distance to the headwater (the hdw_dst attribute). . I tried doing this based on the least largest area (the CUM_ARE attribute) but there were some zero values, I also tried distance to the sea (the LENGTHD attribute, but near the coast I was getting small reaches that were not the main river channel, but were closer to the sea)
MajorCatchmentOuteltReaches <- lapply(seq_along(MajorCatchments$FactSheetZ), function(SingleCatchment){
  #browser()
  CurrentCatchment <- MajorCatchments$FactSheetZ[SingleCatchment]
  CurrentCatchmentReaches <- RECReachNetwork[RECReachNetwork$Catchment == CurrentCatchment,]
  #OutletReach <- CurrentCatchmentReaches$nzsegment[which.max(CurrentCatchmentReaches$headw_dist)]
  OutletReach <- CurrentCatchmentReaches$nzsegment[which(CurrentCatchmentReaches$headw_dist > 30000 & CurrentCatchmentReaches$LENGTHDOWN < 500) ]
  return(data.frame(Catchment = rep(CurrentCatchment,length(OutletReach)),nzsegment = OutletReach))
})
#Convert the list into a dataframe
MajorCatchmentOuteltReachesDF <- do.call(rbind,MajorCatchmentOuteltReaches)
```

Create a bunch of points that represent reaches of sub-catchment confluences over a certain strahler order.
```{r}
SubCatchmentConfluenceReaches <- ReachJunctionFinderByOrder(RECReachNetwork@data,OrderThreshold = 5)

SubCatchmentConfluencePoints <- RECReachNetwork@data[RECReachNetwork@data$nzsegment %in% SubCatchmentConfluenceReaches,]
SubCatchmentConfluencePoints <- SubCatchmentConfluencePoints[,c("nzsegment","upcoordX","upcoordY")]
SubCatchmentConfluencePoints$Reason <- "Base of catchment"

#Turn into a spatial dataframe
SubCatchmentConfluencePointsSpatial <- SpatialPointsDataFrame(coords = SubCatchmentConfluencePoints[,c("upcoordX","upcoordY")],
                                                              data = SubCatchmentConfluencePoints[,c("nzsegment","Reason")],
                                                              proj4string = CRS("+init=epsg:2193"))

#Remove any points that already exist in the Measurement site, Lake site, Estuary site, or Outlet sites
SubCatchmentConfluencePointsSpatial <- SubCatchmentConfluencePointsSpatial[which(!SubCatchmentConfluencePointsSpatial$nzsegment %in% c(MeasurementSites$nzsegment, LakeSites$nzsegment, EstuarySites$nzsegment,RiverMouthSites$nzsegment)),]

#Remove any points that are terminal reaches as they have been manually selected in the "RiverMouthSites"
SubCatchmentConfluencePointsSpatial <- SubCatchmentConfluencePointsSpatial[!SubCatchmentConfluencePointsSpatial$nzsegment %in% SouthlandREC2Utility$nzsegment[SouthlandREC2Utility$isTerminal],]

#Remove any sites from the "unnecesary sites" list
SubCatchmentConfluencePointsSpatial <- SubCatchmentConfluencePointsSpatial[!(SubCatchmentConfluencePointsSpatial$nzsegment %in% UnnecesaryAssessmentSites$nzsegment),]

#Keep the points that are not within lakes
SubCatchmentConfluencePointsSpatial <- SubCatchmentConfluencePointsSpatial[is.na(over(SubCatchmentConfluencePointsSpatial,Lakes)[,1]),]

#Add any additional sites from the manually created "ExtraSites"
SubCatchmentConfluencePointsSpatial <- bind(SubCatchmentConfluencePointsSpatial,ExtraSites[which(!ExtraSites$nzsegment %in% SubCatchmentConfluencePointsSpatial$nzsegment),c("nzsegment","Reason")])

#Add the River names
SubCatchmentConfluencePointsSpatial@data <- join(SubCatchmentConfluencePointsSpatial@data,SouthlandREC2Utility[,c("nzsegment","RiverName")],type="left")

#Remove points not within the overall domain
SubCatchmentConfluencePointsSpatial <- SubCatchmentConfluencePointsSpatial[!is.na(SubCatchmentConfluencePointsSpatial %over% CompleteDomain),]

#Save a copy for viewing in QGIS if required
#writeOGR(SubCatchmentConfluencePointsSpatial, file.path(GISDataDirectory,"SubCatchmentJunctionSites"),layer="SubcatchmentJunctionSites",driver="ESRI Shapefile",overwrite_layer=TRUE)
```


From the load sites, point source sites, and water management subzones outlets, create the required network.
!!This doesn't work with REC3!! as all the nzsegment values are REC2 values.
```{r}
#Combine all the points together in a single cohesive data frame
CombinedPoints <- data.frame(nzsegment = numeric(),Type= character(),Name= character(),Comment=character(), stringsAsFactors = FALSE )
Temporary <- MeasurementSites@data[,c("nzsegment","sID")]
names(Temporary)[2] <- "Name"
Temporary$Type <- "Water quality measurement site"
Temporary2 <- LakeSites@data[,c("nzsegment","LakeName")]
names(Temporary2)[2] <- "Name"
Temporary2$Type <- "Lake"
Temporary2$Comment <- "Not monitored"
Temporary2$Comment[LakeSites@data$Monitored] <- "Monitored"
Temporary3 <- EstuarySitesSpatial@data[,c("nzsegment","Name")]
Temporary3$Type <- "Estuary"
Temporary4 <- SubCatchmentConfluencePointsSpatial@data[,c("nzsegment","RiverName","Reason")]
names(Temporary4)[c(2,3)] <- c("Name","Comment")
Temporary4$Type <- "Various"
Temporary5 <- RiverMouthSites@data[,c("nzsegment","River")]
names(Temporary5)[2] <- "Name"
Temporary5$Type <- "Rivermouth"
CombinedPoints <- rbind.fill(CombinedPoints,Temporary,Temporary2,Temporary3,Temporary4,Temporary5)
#Add Water management class to it
CombinedPoints$WaterPlan <- NZsegmentToWaterPlanClassLookUpTable$WaterPlanV1[match(CombinedPoints$nzsegment, NZsegmentToWaterPlanClassLookUpTable$nzsegment)]

write.table(CombinedPoints,file.path(DataDirectory,"CombinedAssessmentPoints.csv"),sep=",",row.names = FALSE)

#AllPoints <- c(MeasurementSites$nzsegment, PointSourceSites$nzsegment, MajorCatchmentOuteltReachesDF$nzsegment)
AllPoints <- c(MeasurementSites$nzsegment, LakeSites$nzsegment, EstuarySites$nzsegment, SubCatchmentConfluencePointsSpatial$nzsegment, OutletReaches = RiverMouthSites$nzsegment, PointSources = PointSourcesSpatial@data$nzsegment)
LoadNetwork <- lapply(AllPoints, function(x) {DownstreamReachFinder(RECNetwork = RECReachNetwork, SourceReach = x)} )
CompleteNetwork <- unlist(LoadNetwork)
CompleteNetwork <- CompleteNetwork[!duplicated(CompleteNetwork)]
CompleteNetwork <- as.numeric(CompleteNetwork)

CompleteSpatialNetwork <- RECReachNetwork[RECReachNetwork$nzsegment %in% CompleteNetwork,]
```

By request of Ton.

Plot a histogram showing percentage of segments (for strahler order 3 and above) that are in 10 bins of % upstream exotic grassland
On the same histogram show the percentage of location points in each bin

Then repeat for upstream catchment area

Then repeat for Water Plan class
```{r, fig.width=12, fig.height = 12}
#Get all the REC reaches in strahler order 3 and above
RECOrder3andAbove <- RECReachNetwork[RECReachNetwork@data$StreamOrde >= 3,]

#Limit to sites within the overall domain
RECOrder3andAbove <- RECOrder3andAbove[!is.na(RECOrder3andAbove %over% CompleteDomain),]

#Add the pctExoticPasture attribute from the SouthlandREC2Utility data
RECOrder3andAbove@data <- join(RECOrder3andAbove@data,SouthlandREC2Utility[,c("pctExoticPasture","nzsegment")],type="left")

#Add the catchment name as an attribute
RECOrder3andAbove$Catchments <- as.character(unlist(RECOrder3andAbove %over% MajorCatchments))

#There are a few in New River Estuary and Invercargill area that are outside the Invercargill FMU boundary, but only because the boundary doesn't include the estuary
RECOrder3andAbove$Catchments[which(is.na(RECOrder3andAbove$Catchments))] <- "Oreti & Invercargill Catchments"

#These are all the "Network" sites, so I'll call them that in an attribute called "What
RECOrder3andAbove@data$What <- "Network"

#And just extract the dataframe for the graphing
GraphDataFortheCompleteNetwork <- RECOrder3andAbove@data[,c("nzsegment","CUM_AREA","WaterPlan","Catchments","pctExoticPasture","What")]

#Add an attribute which has the total number of segments in the class
GraphDataFortheCompleteNetwork$TotalNo <- nrow(GraphDataFortheCompleteNetwork)

#Add an attribute which has the total number of segments in the class in each catchment
TotalReachesInEachCatchment <- table(GraphDataFortheCompleteNetwork$Catchments)
GraphDataFortheCompleteNetwork$TotalInEachCatchment <- as.vector(TotalReachesInEachCatchment[GraphDataFortheCompleteNetwork$Catchments])

#Just in case, remove any rows that aren't complete (I think there is one missing the pstUpstream pasture attribute
GraphDataFortheCompleteNetwork <- GraphDataFortheCompleteNetwork[complete.cases(GraphDataFortheCompleteNetwork),]

#Create a subset of these that are associated with CASM locations
GraphDataForLocations <- GraphDataFortheCompleteNetwork[which(GraphDataFortheCompleteNetwork$nzsegment %in% AllPoints),]

#And re-label the "What" attribute to "Locations"
GraphDataForLocations$What <- "Locations"

#Update the TotalNo to match the number of locations, and the total number in each catchment
GraphDataForLocations$TotalNo <- nrow(GraphDataForLocations)
TotalLocationsInEachCatchment <- table(GraphDataForLocations$Catchments)
GraphDataForLocations$TotalInEachCatchment <- as.vector(TotalLocationsInEachCatchment[GraphDataForLocations$Catchments])

#Rbind the full network and the locations
GraphData <- rbind(GraphDataFortheCompleteNetwork,GraphDataForLocations)

#Convert the catchment area to km2
GraphData$CUM_AREA <- round(GraphData$CUM_AREA / 1000000,1)

#Rename the attributes of interest to make the automatic graph labelling a bit more intuitive
GraphData <- rename(GraphData, c("CUM_AREA"="Catchment Area (km2)",
                    "pctExoticPasture"="Percentage of catchment in high producing pasture",
                    "WaterPlan"="Water Plan Classes"))

#Initialise an empty plot list
PlotList <- list()

AttributesOfInterest <- c("Catchment Area (km2)","Percentage of catchment in high producing pasture")
for (AttributeToBePlotted in AttributesOfInterest){

FullDomainPlot <- ggplot(GraphData, aes(x=GraphData[,AttributeToBePlotted],y=stat(count) * 100,fill=What,weight=1/TotalNo)) + geom_histogram(bins=10,colour="grey",position="dodge") + labs(fill="", title = "All catchments",x = AttributeToBePlotted, y = "Percentage of total")

CatchmentPlot <- ggplot(GraphData, aes(x=GraphData[,AttributeToBePlotted],y=stat(count) * 100,fill=What,weight=1/TotalInEachCatchment))+ geom_histogram(bins=10,colour="grey",position="dodge") + labs(fill="", x = AttributeToBePlotted, y = "Percentage of total") + facet_wrap(. ~Catchments,ncol=2)

PlotList <- c(PlotList,list(FullDomainPlot),list(CatchmentPlot))
}

WaterPlanFullDomainPlot <- ggplot(GraphData, aes(x=GraphData[,"Water Plan Classes"],y=stat(count) * 100,fill=What,weight=1/TotalNo)) + geom_bar(colour="grey",position="dodge") + labs(fill="",title = "All catchments", x = "Water Plan Classes", y = "Percentage of total") 

WaterPlanByCatchmentPlot <- ggplot(GraphData, aes(x=GraphData[,"Water Plan Classes"],y=stat(count) * 100,fill=What,weight=1/TotalInEachCatchment))+ geom_bar(colour="grey",position="dodge") + labs(fill="", x = "Water Plan Classes", y = "Percentage of total") + theme(axis.text.x = element_text(angle = 45, hjust=1))+ facet_wrap(. ~Catchments,ncol=2)

PlotList <- c(PlotList,list(WaterPlanFullDomainPlot),list(WaterPlanByCatchmentPlot))

library(gridExtra)

# Three pages of plots in one PDF file
{
pdf(file.path(DataDirectory,"CASM Node location representativeness.pdf"), 8.27, 11.69)
for (i in seq(1, length(PlotList), 2)) {
grid.arrange(PlotList[[i]],
             PlotList[[i+1]],
             nrow=3,
             layout_matrix = rbind(1,2,2,2))

}
dev.off()
}


```



Then create a tributary table ready for CASM
**** This needs an Outlet Reach Name lookup table to be manually prepared ****
```{r}

NetworkLabelList <- NetworkLabeler(CompleteSpatialNetwork)


#Add the tributary labels to the network
SegmentToLabelLookUpTable <- do.call(rbind,NetworkLabelList)
CompleteSpatialNetwork@data$Label <- SegmentToLabelLookUpTable$Label[match(CompleteSpatialNetwork@data$nzsegment,SegmentToLabelLookUpTable$nzsgmnt)]
#Add the prefixed labels to the network
SegmentToPrefixedLabelLookUpTable <- ReachLabeler(NetworkLabelList, OutletReachNames)
CompleteSpatialNetwork@data$PrefixedLabel <- SegmentToPrefixedLabelLookUpTable$Prefixedlabel[match(CompleteSpatialNetwork@data$nzsegment,SegmentToPrefixedLabelLookUpTable$nzsgmnt)]

#Add the 
#Save the network as a spatial file
writeOGR(CompleteSpatialNetwork, file.path(GISDataDirectory), "CASM-StreamNetwork", driver="ESRI Shapefile",overwrite_layer=TRUE)

TributaryConnectionTable <- TributaryConnectionCreator(RECNetwork = CompleteSpatialNetwork, TributaryLabelList = NetworkLabelList)
```

Then create a point source table ready for CASM,
a measurement site table ready for CASM,
and a diffuse inputs table ready for CASM
```{r}
#Create a dataframe of just the nzsegment number and the site name
PointSourceNodes <- PointSourceSites[,c("Site.Name","nzsegment")]

#Standardise the column names so that it matches the expected format in the CASMNodeTablePreparer() function
names(PointSourceNodes) <- c("NodeName","nzsgmnt")

#Prepare the CASM table with the bonus nzsegment column
PointSourceTable <- CASMNodeTablePreparer(CASMRECNetwork = CompleteSpatialNetwork, NetworkLabelList = NetworkLabelList, TributaryConnectionTable = TributaryConnectionTable,CASMNodes = PointSourceNodes )

#rename the columns to match the CASM requirements
names(PointSourceTable) <- c("nzsgmnt","Point Source Name","Receiving Stream","Location (km)")
 
#Need to add the point source load to the table
PointSourceTable$"Annual Load (kg/yr)" <- round(PointSourceSites$TN.kgpy[match(PointSourceTable$nzsgmnt,PointSourceSites$nzsegment)],0)
```



#Repeat for the measurement sites
```{r}
MeasurementSiteNodes <- MeasurementSites[,c("sID","nzsegment")]
names(MeasurementSiteNodes) <- c("NodeName","nzsgmnt")
MeasurementSiteTable <- CASMNodeTablePreparer(CASMRECNetwork = CompleteSpatialNetwork, NetworkLabelList = NetworkLabelList, TributaryConnectionTable = TributaryConnectionTable,CASMNodes= MeasurementSiteNodes)

#rename the columns to match the CASM conventions
names(MeasurementSiteTable) <- c("nzsgmnt","Site Name or No","Target Stream","Downstream Location (km)")

#Add the mean annual flow to the table
MeasurementSiteTable$"Mean flow (m3/s)" <- round(REC2MeanFlow$QMean[match(MeasurementSiteTable$nzsgmnt, REC2MeanFlow$nzsegment)],1)

#Add a variety of other fields from the Measurement Site data
MeasurementSiteTable$'Load (kg/yr)' <- round(MeasurementSites$load[match(MeasurementSiteTable$"Site Name or No", MeasurementSites$sID)],1)
MeasurementSiteTable$'Load Lci (kg/yr)' <- round(MeasurementSites$load_Lci[match(MeasurementSiteTable$"Site Name or No", MeasurementSites$sID)],1)
MeasurementSiteTable$'Load Uci (kg/yr)' <- round(MeasurementSites$load_Uci[match(MeasurementSiteTable$"Site Name or No", MeasurementSites$sID)],1)
```

#Repeat for diffuse inputs. This is a special case, because once the points have been found, they need to be joined with all the different landuse/LUC options
```{r}
#Start with all the diffuse source input nodes. These are the sub-management zone outlets
DiffuseInputsSiteNodes <- ManagementSubZoneOutletReachesDF
names(DiffuseInputsSiteNodes) <- c("NodeName","nzsgmnt")

#Build up the table of tributary names and locations associated with the diffuse source input sites
DiffuseInputsSiteTable <- CASMNodeTablePreparer(CASMRECNetwork = CompleteSpatialNetwork, NetworkLabelList = NetworkLabelList, TributaryConnectionTable = TributaryConnectionTable,CASMNodes= DiffuseInputsSiteNodes)

#Now create a bigger version, with a row for each of the different landuse/LUC combinations within each sub-management zone
DiffuseInputsSiteExtendedTable <- SubZoneLanduseLUCSpatial@data

#Add the locations that we have just previously determined
DiffuseInputsSiteExtendedTable[,c("TribLocn","TribName")] <- DiffuseInputsSiteTable[match(SubZoneLanduseLUCSpatial@data$Zone_Code, DiffuseInputsSiteTable$CASMNodeName),c("TribLocn","TribName")]

#Add the leach rates
DiffuseLeachRateData <- DiffuseLoadTableCreator(ZoneLanduseLUCRaster = ,LeachRates = LeachRate)
DiffuseInputsSiteExtendedTable$"LeachRates"<- DiffuseLeachRateData$LeachRate[match(DiffuseInputsSiteExtendedTable$CombinedClassName,DiffuseLeachRateData$CombinedClassName)]

#Need to use raster-calculated area rather than polygon areas
DiffuseInputsSiteExtendedTable$`RasterBased Land Area (ha)` <- DiffuseLeachRateData$Hectares[match(DiffuseInputsSiteExtendedTable$CombinedClassName,DiffuseLeachRateData$CombinedClassName)]
#Remove all the surplus combined names. The raster version has much less.
DiffuseInputsSiteExtendedTable <- DiffuseInputsSiteExtendedTable[complete.cases(DiffuseInputsSiteExtendedTable),]

#I now need to adjust the locations of all the different landuse/LUC options for a single diffuse source point so that they are not all on exactly the same spot.
#Work along each sub management zone, get all the landuse/LUC classes, and increment the locations by 0.1 km
DiffuseInputsSiteExtendedTable$AdjustedTriblocn <- DiffuseInputsSiteExtendedTable$TribLocn
UniqueSubZones <- unique(DiffuseInputsSiteExtendedTable$Zone_Code)
for(SubZoneIndex in seq_along(UniqueSubZones)) {
  #get the subzone of interest
  SubZone <- UniqueSubZones[SubZoneIndex]
  
  #Get all the landuse/LUC classes in the subzone
  RowsOfInterest <- which(DiffuseInputsSiteExtendedTable$Zone_Code == SubZone)
  DiffuseInputsSiteExtendedTable$AdjustedTriblocn[RowsOfInterest] <- DiffuseInputsSiteExtendedTable$TribLocn[RowsOfInterest] + seq(0,by = 0.01, length.out = length(RowsOfInterest))
}

#rename the columns to match the CASM conventions
names(DiffuseInputsSiteExtendedTable) <- c("Landuse","LUC","Zone_Code","Polygon Land Area (ha)","Node Name","Original location (km)", "Receiving Stream","Export Coeff (kg/ha/yr)","Land Area (ha)","Discharge Location (km)")

```


An overview plot is required showing the various points and the underlying relevant spatial data.
This plot is pre-modelling to share with the project  participants so that they can check that the points are in the right place.
Chlopleth mapping is from here https://rstudio.github.io/leaflet/choropleths.html
Raster mapping is from here https://stackoverflow.com/questions/59110756/failed-to-add-a-categorical-legend-in-leaflet-in-r-using-addlegendlabels

Speed improvements were undertaken following https://stackoverflow.com/questions/44356224/leaflet-shiny-integration-slow
```{r}


#RECForMaps <- RECReachNetwork[(sqrt(RECReachNetwork@data$CUM_AREA)/10000 > 1) | (RECReachNetwork@data$nzsegment %in% CompleteNetwork),]
#RECForMaps$LineWidthPixels <- pmax(1,as.integer(sqrt(RECForMaps@data$CUM_AREA)/10000)) #SCale the line width, with a minimum of 1 pixel

#Just get the network needed for the map. For REC3, the headw_dist divisor is 2000, for RECV2 it is 200, so need to edit this.
#RECForMaps <- RECReachNetwork[(sqrt(RECReachNetwork@data$headw_dist)/100 > 1) | (RECReachNetwork@data$nzsegment %in% CompleteNetwork),]
RECForMaps <- RECReachNetwork[(RECReachNetwork@data$nzsegment %in% CompleteNetwork),]
RECForMaps$LineWidthPixels <- pmax(1,as.integer(sqrt(RECForMaps@data$headw_dist)/100)) #SCale the line width, with a minimum of 1 pixel

RECForMaps <- RECForMaps[,c("LineWidthPixels","WaterPlan")]
RECForMaps$WaterPlan <- as.factor(RECForMaps$WaterPlan)
RECForMaps <- ms_simplify(RECForMaps)



#Reproject the vector spatial data to the maps projection ready for plotting
#Note that the raster data was reprojected when it was loaded.
#SpatialData <- list(MeasurementSites=MeasurementSitesSpatial, PointSourceSites=PointSourceSitesSpatial,
#                    SubZones=SubZonePolygons,RiverNetwork=CompleteSpatialNetwork)
SpatialData <- list(MeasurementSites=MeasurementSites,LakeSites=LakeSites,EstuarySites=EstuarySitesSpatial,SubCatchmentSites=SubCatchmentConfluencePointsSpatial,RiverMouthSites=RiverMouthSites, RiverNetwork=RECForMaps,MajorCatchments=MajorCatchments,GroundwaterZones=GroundwaterZones, PointSourceSites=PointSourcesSpatial)
MapData <- lapply(SpatialData, spTransform,CRS("+init=epsg:4326"))

MapData$Physiography <- PhysiographyRasterWGS84
#MapData$WaterPlan <- WaterPlanRasterWGS84

MeasurementSiteLabels <- lapply(seq(nrow(MapData$MeasurementSites@data)), function(i) {
  paste0("Measurement site:", '</br>', 
          MapData$MeasurementSites@data[i, "sID"]) 
})

EstuarySiteLabels <- lapply(seq(nrow(MapData$EstuarySites@data)), function(i) {
  paste0("Estuary site:", '</br>', 
          MapData$EstuarySites@data[i, "Name"]) 
})

UnMonitoredLakeSiteLabels <- lapply(which(!MapData$LakeSites@data$Monitored), function(i) {
  paste0("Lake site:", '</br>', 
          MapData$LakeSites@data[i, "LakeName"]) 
})

MonitoredLakeSiteLabels <- lapply(which(MapData$LakeSites@data$Monitored), function(i) {
  paste0("Lake site:", '</br>', 
          MapData$LakeSites@data[i, "LakeName"]) 
})

SubCatchmentSites <- lapply(seq(nrow(MapData$SubCatchmentSites@data)), function(i) {
  paste0("Subcatchment site: ",  
          MapData$SubCatchmentSites@data[i, "RiverName"],'</br>',MapData$SubCatchmentSites@data[i, "Reason"]) 
})

RiverMouthSiteLabels <- lapply(seq(nrow(MapData$RiverMouthSites@data)), function(i) {
  paste0("Rivermouth site: ",'</br>',MapData$RiverMouthSites@data[i, "River"]) 
})

#Setup the map
map <- leaflet::leaflet() %>% 
  leaflet::addProviderTiles(providers$OpenStreetMap) %>%
  setView(lng=168,lat=-46.0,zoom=9)

#Add the main catchments
Catchmentlabels <- sprintf(
  "<strong>Major Catchment</strong><br/>%s ",
  MapData$MajorCatchments@data$FactSheetZ
) %>% lapply(htmltools::HTML)

MCpal <- colorFactor("Dark2", domain = MapData$MajorCatchments@data$FactSheetZ)

map <- map %>%
  addPolygons(data=MapData$MajorCatchments,
  fillOpacity = 0,
  weight = 2,
  opacity = 1,
  color = "grey",
  highlight = highlightOptions(
    weight = 5,
    color = "#666"),
  label = Catchmentlabels,
  group="Major Catchments")

#Add the point source sites
PointSourceLabels <- sprintf(
  "<strong>Point source</strong><br/>%s ",
  MapData$PointSourceSite@data$Source
) %>% lapply(htmltools::HTML)

map <- map %>%
  addMarkers(data=MapData$PointSourceSites,
                   icon= ~ icons(iconUrl = "Data/Icon_warning.png",iconAnchorX = 20, iconAnchorY = 0),  #Note the use of a subdirectory called Data to keep the icon file in. This is done to replicate the situation on the Shiny App so that I can simply copy the map script directly over.
                   label = PointSourceLabels,
                   #color = "black",
                   #fillOpacity = 0.5,
                   group="Point Sources")

#Add the groundwater zones
GroundwaterLabels <- sprintf(
  "<strong>Groundwater Zone</strong><br/>%s ",
  MapData$GroundwaterZones@data$Groundwate
) %>% lapply(htmltools::HTML)
GWpal <- colorFactor("YlOrRd", domain = MapData$GroundwaterZones@data$OBJECTID)

map <- map %>%
  addPolygons(data=MapData$GroundwaterZones,
  fillOpacity = 0,
  weight = 2,
  opacity = 1,
  color = "grey",
  highlight = highlightOptions(
    weight = 5,
    color = "#666"),
  label = GroundwaterLabels,
  group="Groundwater Management Zones")

#Add the Physiography raster. Note the custom palette to Match the Environment Southland colours as given in https://www.arcgis.com/home/webmap/viewer.html?useExisting=1&layers=fe2093666347411d92b4d0d5f4677af7
Physpal <- colorFactor(palette=c("#ffff73","#38a800","#7a1973","#9ed7c2","#aa66cd","#ffaa00","#734c00","#002673","#00c5ff","#9c9c9c"), levels <- c(1,2,3,4,5,6,7,8,9,10),
                    na.color = "transparent")
map <- map %>%
  addRasterImage(MapData$Physiography, colors = Physpal, opacity = 1, group = "Physiographic Zones") %>%  
  addLegend(pal = Physpal, 
            values = values(MapData$Physiography),
            title = "Physiography",
            opacity = 1,
            labFormat  = labelFormat(
            transform = function(x) {
              levels(MapData$Physiography)[[1]]$Physiography[which(levels(MapData$Physiography)[[1]]$ID == x)]
            }),
            layerId = "Physiography",
            group="Physiographic Zones")

#Add the river network coloured by Water Plan Class. Note the custom palette set to match the Environment Southland choice of colours on their GIS page: http://gis.es.govt.nz/index.aspx?app=water-and-land
WPpal2 <- colorFactor(palette=c("#a4d1a4","#ffc34d","#ffff9e","#dcb496","#ff9ee9","#ff7f7f","#68a84d"), levels <- levels(MapData$RiverNetwork$WaterPlan),
                    na.color = "transparent")

map <- map %>%
  addPolylines(data = MapData$RiverNetwork, color= ~WPpal2(WaterPlan), weight = ~LineWidthPixels, label = ~WaterPlan, opacity = 1,group= "Water Plan Classes") %>%
    addLegend(pal = WPpal2, 
            values = MapData$RiverNetwork$WaterPlan,
            title = "Water Plan Classes",
            opacity = 1,
            #labFormat  = labelFormat(
            #transform = function(x) {
            #  levels(MapData$RiverNetwork$WaterPlan)[[1]]$WaterPlanClass[which(levels(MapData$RiverNetwork$WaterPlan)[[1]]$ID == x)]
            #}),
            layerId = "Water Plan Classess",
            group="Water Plan Classes")
  

map <- map %>%
  addCircleMarkers(data = MapData$MeasurementSites, color = "#FF3333",fillOpacity = 0.5, label = lapply(MeasurementSiteLabels, htmltools::HTML)) %>%
  addCircleMarkers(data = MapData$LakeSites[MapData$LakeSites@data$Monitored,], color = "darkorange", fillOpacity = 0.5, label = lapply(MonitoredLakeSiteLabels, htmltools::HTML)) %>%
  addCircleMarkers(data = MapData$LakeSites[!MapData$LakeSites@data$Monitored,], color = "yellow", fillOpacity = 0.5, label = lapply(UnMonitoredLakeSiteLabels, htmltools::HTML)) %>%
  addCircleMarkers(data = MapData$EstuarySites, color = "turquoise", fillOpacity = 0.5,label = lapply(EstuarySiteLabels, htmltools::HTML)) %>%
  addCircleMarkers(data = MapData$RiverMouthSites, color = "brown", fillOpacity = 0.5,label = lapply(RiverMouthSiteLabels, htmltools::HTML)) %>%
  addCircleMarkers(data = MapData$SubCatchmentSites, color = "#0066CC", fillOpacity = 0.5,label = lapply(SubCatchmentSites, htmltools::HTML)) %>%
  
  addPolylines(data = MapData$RiverNetwork, color= "blue", weight = ~LineWidthPixels,group = "River Network") %>%
  
  addLegend("topright", colors = c("#FF3333","darkorange","yellow","turquoise","brown","lightblue"), labels = c("RWQ","Lake-Monitored","Lake-not monitored","Estuary","River Mouth","Subcatchment"),
            title = "Assessment point<br>locations",
            opacity = 1) %>%
  
  addLayersControl(
          overlayGroups =c("Major Catchments","Point Sources","Water Plan Classes","Physiographic Zones", "River Network", "Groundwater Management Zones"),
          options = layersControlOptions(collapsed=FALSE)
          ) %>%
  
  hideGroup(c("Major Catchments","Point Sources","Water Plan Classes","Groundwater Management Zones","River Network","Physiographic Zones"))

map

#save the mapdata as an R file so that it can be used in an RShinyApp
saveRDS(MapData,file.path(ProjectDirectory,"/R/CASM_Southland/ShinyApp/Data","SpatialData.RDS"))
saveRDS(map,file.path(ProjectDirectory,"/R/CASM_Southland/ShinyApp/Data","map.RDS"))
#Copy the icon file to the RShiny directory
file.copy(from = "Icon_warning.png", to=file.path(ProjectDirectory, "/R/CASM_Southland/ShinyApp/Data","Icon_warning.png"))
```


The tributary connection table needs to be converted to an Excel Spreadsheet.


I need to create an excel table of CASM-Nodes, CASM-Reach-Names, CASM-Reach-Locations, CASM-Reach-Areas, CASM-Reach-Exp.Coeff
```{r}


Out <- createWorkbook()

addWorksheet(Out, "River Network")

writeData(Out, sheet = "River Network", x = TributaryConnectionTable[c("Tributary Name","Confluence Stream","Confluence Location (km)")])

addWorksheet(Out, "Point Source")

writeData(Out, sheet = "Point Source", x = PointSourceTable[,-1])

addWorksheet(Out, "Water Quality Stations")

writeData(Out, sheet = "Water Quality Stations", x = MeasurementSiteTable[,-1])

addWorksheet(Out, "Diffuse Inputs")


writeData(Out, sheet = "Diffuse Inputs", x = DiffuseInputsSiteExtendedTable[,c("Node Name","Receiving Stream","Discharge Location (km)","Land Area (ha)","Export Coeff (kg/ha/yr)")])

saveWorkbook(Out, file.path(DataDirectory,"CASM-Inputs.xlsx"), overwrite = T)
```
 By way of a check, it will be helpful to compare the total sub-management zone loads from the gridded leachrate data with the total sub-management zone loads from the zone/landuse/LUC data.
 Start with the leach rate raster data, and get the average leachrate for each zone and multiply by the area.
 Note that  I need to use the subzones from the SubZone
 
 Then, as a check, get the load for each zone-landuse-LUC combination, and sum in each zone.
 It would also be good to add a check of total load in catchments upstream of a water quality network being more than the total load measured. If they were less, then the attenuation would have to be greater than 1!
```{r}
#Note that to ensure I am comparing apples with apples, I am using the SubZoneLandUseLUCSpatial data to find the SubZone areas (rather than using the pre-prepared cleaned sub zone spatial data which has been "cleaned" so is slightly different in area!!)
test <- unionSpatialPolygons(SubZoneLanduseLUCSpatial,IDs = SubZoneLanduseLUCSpatial@data$Zone_Code )
testid <- sapply(slot(test, "polygons"), function(x) slot(x, "ID"))
test2 <- SpatialPolygonsDataFrame(test,data.frame(Zone_Code = testid,row.names = testid))

Zoneleachrates <- raster::extract(LeachRate, test2, fun = mean, na.rm=TRUE, sp=TRUE, weights = TRUE)
Zoneleachrates$area <- raster::area(Zoneleachrates)
Zoneleachrates$loads <- with(Zoneleachrates@data,layer * area / 10000)

DiffuseInputsSiteExtendedTable$load <- DiffuseInputsSiteExtendedTable$`Export Coeff (kg/ha/yr)` * DiffuseInputsSiteExtendedTable$`Land Area (ha)`
library(plyr)
bob <- ddply(DiffuseInputsSiteExtendedTable, "Zone_Code", function(x) sum(x$load, na.rm=TRUE))

ddply(DiffuseInputsSiteExtendedTable, "Zone_Code", function(x) sum(x$'Land Area (ha)', na.rm=TRUE))

#Ideally the loads from the raster and the DiffuseinputsSiteExtendedTable would be the same, but they are not!!
#But they are close for most water management sub-zones
charlie <- cbind(Zoneleachrates@data,bob)
charlie$load_diff <- charlie$loads - charlie$V1
charlie$load_diff_percent <- round(charlie$load_diff / charlie$loads * 100,0)
print(charlie)
```
 

```{r}
# NOT RUN {
# !formatR
library(leaflet)
# a manual legend
leaflet() %>% addTiles() %>% addLegend(
  position = "bottomright",
  colors = rgb(t(col2rgb(palette())) / 255),
  labels = palette(), opacity = 1,
  title = "An Obvious Legend"
)

# }
# NOT RUN {
# an automatic legend derived from the color palette
df <- local({
  n <- 300; x <- rnorm(n); y <- rnorm(n)
  z <- sqrt(x ^ 2 + y ^ 2); z[sample(n, 10)] <- NA
  data.frame(x, y, z)
})
pal <- colorNumeric("OrRd", df$z)
leaflet(df) %>%
  addTiles() %>%
  addCircleMarkers(~x, ~y, color = ~pal(z), group = "circles") %>%
  addLegend(pal = pal, values = ~z, group = "circles", position = "bottomleft") %>%
  addLayersControl(overlayGroups = c("circles"))

# format legend labels
df <- data.frame(x = rnorm(100), y = rexp(100, 2), z = runif(100))
pal <- colorBin("PuOr", df$z, bins = c(0, .1, .4, .9, 1))
leaflet(df) %>%
  addTiles() %>%
  addCircleMarkers(~x, ~y, color = ~pal(z), group = "circles") %>%
  addLegend(pal = pal, values = ~z, group = "circles", position = "bottomleft") %>%
  addLayersControl(overlayGroups = c("circles"))

leaflet(df) %>%
  addTiles() %>%
  addCircleMarkers(~x, ~y, color = ~pal(z), group = "circles") %>%
  addLegend(pal = pal, values = ~z, labFormat = labelFormat(
    prefix = "(", suffix = ")%", between = ", ",
    transform = function(x) 100 * x
  ),  group = "circles", position = "bottomleft" ) %>%
  addLayersControl(overlayGroups = c("circles"))
# }
```

