---
title: "R Notebook to preprocess water quality data for use with CASM, for Horizons"
output: html_notebook
---

load some libraries
```{r}
if (!require(rgdal)) install.packages("rgdal"); library(rgdal)                #used for spatial processing
if (!require(ggplot2)) install.packages("ggplot2"); library(ggplot2)                #used for plotting
if (!require(gridExtra)) install.packages("gridExtra"); library(gridExtra)                #Used for plotting multiple plots to output
if (!require(plyr)) install.packages("plyr"); library(plyr)                #used for the join function
if (!require(dplyr)) install.packages("dplyr"); library(dplyr)                #used for the rename function
if (!require(knitr)) install.packages("knitr"); library(knitr)                #used to make nice looking tables
if (!require(rgeos)) install.packages("rgeos"); library(rgeos)                #used for spatial processing
if (!require(raster)) install.packages("raster"); library(raster)                #used for spatial processing
if (!require(leaflet)) install.packages("leaflet"); library(leaflet)                #used for spatial processing
if (!require(rmapshaper)) install.packages("rmapshaper"); library(rmapshaper)                #used for spatial processing
if (!require(devtools)) install.packages("devtools"); library(devtools)                #Needed to load libraries from github
if (!require(tictoc)) install.packages("tictoc"); library(tictoc)                         #used for timing processing
if (!require(openxlsx)) install.packages('openxlsx'); library(openxlsx)
  if (!require(rasterVis)) install.packages("rasterVis"); library(rasterVis)                #used for plotting discrete rasters
if (!require(CASMPrePostProcessor)) install_github("rainfallnz/CASMPrePostProcessor"); library(CASMPrePostProcessor)                #Needed to load libraries from github
source("D:\\Projects\\LWP\\SouthlandRegionalForumModelling\\R\\CASM_Southland\\RECReachNaming.R")

```

Some useful functions
```{r}
#I need to name the reach segments to match the real world names.
#Some can be looked up, but these will need to be manually checked.
#The rest need to be manually named.
#This function accepts a spatial network and returns a labelled version

NetworkLabeller <- function(RECV2Network = CompleteSpatialNetwork){

#Name as much as possible from the LINZ river naming spatial data sets
NamedCompleteSpatialNetwork <- RECReachNamer(RECV2Network = RECV2Network)

#Talk amongst yourselves while this layer is manually checked in QGIS
#st_write(NamedCompleteSpatialNetwork, file.path(GISDataDirectory), "CASM-StreamNetworkForNaming", driver="ESRI Shapefile",overwrite_layer=TRUE)

#Load in the csv file with a direct nzsegment-to-name relationship (manually prepared!)
ExtraRECReachLabels <- read.table(ExtraRECReachLabelsFile,sep=",",stringsAsFactors = FALSE, header=TRUE)

#Use this to update the names
IndexOfNamesToUpdate <- which(NamedCompleteSpatialNetwork$nzsegment %in% ExtraRECReachLabels$nzsegment)
NamedCompleteSpatialNetwork$name[IndexOfNamesToUpdate] <- ExtraRECReachLabels$name[match(NamedCompleteSpatialNetwork$nzsegment[IndexOfNamesToUpdate],ExtraRECReachLabels$nzsegment)]

#Use the estuary sites list to update any reaches that don't already have a name (useful for all the outlet reaches)
#Find which of the estuary reach numbers need updating
EstuaryReachesToBeUpdated <- which(NamedCompleteSpatialNetwork$nzsegment %in% EstuarySites$nzsegment & NamedCompleteSpatialNetwork$name %in% c("TBC",NA))
#Then update them
NamedCompleteSpatialNetwork$name[EstuaryReachesToBeUpdated] <- EstuarySites$Name[match(NamedCompleteSpatialNetwork$nzsegment[EstuaryReachesToBeUpdated],EstuarySites$nzsegment)]

#Name all remaining reaches by checking  the name immediately downstream or by getting manual input
NetworkLabelList <- NetworkNamer(RECNetwork = NamedCompleteSpatialNetwork)

#Add the tributary labels to the network
#SegmentToLabelLookUpTable <- do.call(rbind,NetworkLabelList)
#RECV2Network@data$Label <- SegmentToLabelLookUpTable$name[match(RECV2Network@data$nzsegment,SegmentToLabelLookUpTable$nzsegment)]
return(NetworkLabelList)
}
```


Set directories and data file names
```{r}
#Set the project directory
ProjectDirectory <- "D:\\Projects\\LWP\\SouthlandRegionalForumModelling"       #Tim Kerr's Windows Home laptop

#Set the data directory
DataDirectory     <- file.path(ProjectDirectory, "Data")

#Set the GIS directory
GISDataDirectory  <- file.path(DataDirectory,"GIS")

#Set some R data filenames from the LWP data store
REC_MeanFlowFile <- file.path(DataDirectory,"REC2MeanFlow.RData")  #This is an RData file
REC2UtilityFile <- file.path(DataDirectory,"REC2Utility.rdata")  #This contains a dataframe called REC2Utility, which has a whole bunch of REC2 attributes, including river names
REC2UtilityExtraFile <- file.path(DataDirectory,"FINAL_REC2_FOR_PREDICTIONS.Rdata")  #This contains a dataframe called REC2, which has a whole bunch of additional REC2 attributes, 

#Set the names of the shapefile spatial data in ESRI format
#REC data is available from the MfE data service. See https://data.mfe.govt.nz/layer/51826-river-environment-classification-manawatu-2010/ and https://data.mfe.govt.nz/layer/51847-river-environment-classification-watershed-manawatu-2010/

REC_rivers              <- "ES_REC2V5_Riverlines"
#Or an REC3 version
#REC_rivers             <- "ES_REC3_Riverlines"
REC_Catchments         <- file.path(GISDataDirectory,"ES_REC2_Watersheds","ES_REC2_Watersheds") #An ESRI polygon shape file with Environment Southland Plan Classses

#WaterQualityStationFile <- "WaterQualitySites" #A Point shape file
#LakeSiteFile            <- "LakeSites"  #A Point shape file
LakePolygonFile         <- "NZLRIClip_Lakes" #A polygon shape file

ExtraCASMNodeSiteFile   <- "ExtraCASMNodes"  #A Point Shape File
RiverOutletsFile        <- "RiverMouthSites" #A Point Shape File

MajorCatchmentsFile     <- "FactsheetZoneAreas"   #A polygon shapefile
GroundwaterZonesFile    <- "Environment_Southland_Groundwater_Management_Zones_RWP_2010" #AI polygon shapefile
PhysiographicDataFile   <- file.path(GISDataDirectory,"Environment_Southland_Physiographic_Zones","Environment_Southland_Physiographic_Zones.shp") #A polygon shapefile
WaterPlanClassificationFile <- "WaterPlanClassification" #A Shape file
DiffuseLoadSourceAreasFile <- file.path(GISDataDirectory,"CASMDiffuseLoadSourceAreas","CASMDiffuseLoadSourceAreas.shp")

LanduseShapeFile        <- file.path(GISDataDirectory,"LanduseLayers/LandUse2017/LandUse2017.shp")
SoilDrainageShapeFile   <- file.path(GISDataDirectory,"LanduseLayers/Soil_drainage/Soil_drainage.shp")
SlopeClassShapeFile     <- file.path(GISDataDirectory,"LanduseLayers/LRI_Slope_Layer/LRI_Slope_Layer.shp")
PrecipIrrigShapeFile    <- file.path(GISDataDirectory,"LanduseLayers/PrecipitationClass_withIrri/PrecipitationClass_withIrri.shp")


#Set the name of raster file data in geoTiff format
WaterPlanClassificationRasterFile <- file.path(GISDataDirectory,"ES_PlanClassification.tif") #A raster file
LeachRateRasterFile     <- file.path(GISDataDirectory,"LeachRateRaster 250 x 250.tif")
PredictorRasterFile     <- file.path(GISDataDirectory,"PredictorRaster 250 x 250.tif")
PhysiographyBasedAttenuationEstimatesFile <- file.path(GISDataDirectory,"PhysioAttenuationEstimates 250 x 250.tif")

#Set the names of some text tables in csv format
LakeSiteFile            <- file.path(DataDirectory,"Lakes_ToIncludeAsAssessmentPoints.csv")
WaterQualityStationFile <- file.path(DataDirectory,"WQStationLocations_May2020.csv")
WaterQualityDataFile    <-file.path(DataDirectory,"WaterQualityStationLoadConcData.csv")
#OutletReachNamesFile   <- "OutletReachNames.csv"
EstuarySiteFile         <- "Estuaries.csv"
#NZsegmentToWaterPlanClassLookUpTableFile <-  file.path(DataDirectory,"NZsegmentToWaterPlan.csv")
NZsegmentToWaterPlanClassLookUpTableFile <-  file.path(DataDirectory,"REC2WaterPlanV1.csv")
UnnecesaryAssessmentSitesFile <-  file.path(DataDirectory,"SubcatchmentJunctionSitesNotRequired.csv")
PointSourceSitesFile    <- file.path(DataDirectory,"SldPointSourceLoadsNZSegmentAssigned.csv")
#TeAoMaramaSitesFile    <- file.path(DataDirectory,"TeAoMaramaSites.csv")
TeAoMaramaSitesFile     <- file.path(DataDirectory,"TeAoMaramaSites_UTF_8.csv")
ExtraRECReachLabelsFile <- file.path(DataDirectory,"RECV2ReachNameExtras.csv")
CASMBasinLookupTableFile<- file.path(DataDirectory,"CASMBasinToSouthlandFMULookupTable.csv")
CASMnzsegOverrideFile   <- file.path(DataDirectory,"CASMnzsegmentOverideForLocation.csv")


#Set the names of some Excel workbooks
LeachRateLUTFile        <- file.path(DataDirectory,"Losses Lookup Table DRAFT_V2_1.xlsx")   #This was supplied by Ewen from Environment Southland, but edited by Tim Kerr to make the Landuse classes match the spatial data
PhysiographicAttenuationLookupTableFile <- file.path(DataDirectory,"Relative Attenuation Estimates.xlsx")

```


load data
```{r}
#Load the major catchments
MajorCatchments <- readOGR(dsn =file.path(GISDataDirectory),
                           layer = MajorCatchmentsFile, stringsAsFactors = FALSE)
MajorCatchments <- spTransform(MajorCatchments,CRS("+init=epsg:2193") )
#Ditch Fiordland and Stewart Island
MajorCatchments <- MajorCatchments[-which(MajorCatchments$FactSheetZ %in% c("Fiordland","Stewart Island/ Rakiura Zone","Coastal Islands")),]
#Ditch the NA catchemnts
MajorCatchments <- MajorCatchments[!is.na(MajorCatchments$FactSheetZ),]
MajorCatchments <- ms_simplify(MajorCatchments)
projection(MajorCatchments) <- CRS("+init=epsg:2193")   #re-assign the NZTM specific projection as it gets dropped by the ms_simplify function.

#Create a full domain (with help to clean it from https://stackoverflow.com/questions/12663263/dissolve-holes-in-polygon-in-r )
CompleteDomain <- gUnaryUnion(MajorCatchments)
outerRings = Filter(function(f){f@ringDir==1},CompleteDomain@polygons[[1]]@Polygons)
CompleteDomain = SpatialPolygons(list(Polygons(outerRings,ID=1)))
crs(CompleteDomain) <- crs(MajorCatchments)

#Load the lookup table between REC2 nzsegment and Environment Southland's Water Plan class
NZsegmentToWaterPlanClassLookUpTable <- read.table(NZsegmentToWaterPlanClassLookUpTableFile, sep=",", stringsAsFactors = FALSE,header = TRUE)

#If the lookup table is not available then it can be recreated using the code immediately below
# {
# #Read in the REC riverlines that have been converted to points
# REC2RiverLinePOints <- readOGR(dsn = GISDataDirectory,layer = "ES_REC2_Riverline_Vertices_WaterPlan")
# 
# REC2RiverlinePointData <- REC2RiverLinePOints@data
# rm(REC2RiverLinePOints) #to free up memory
# 
# #Aggregate on NZSegment, returning the majority of WaterPlan
# REC2ToWaterPlanLUT <- aggregate(REC2RiverlinePointData$WaterPlan,list(REC2RiverlinePointData$nzsegment),FUN= modal)
# names(REC2ToWaterPlanLUT) <- c("nzsegment","Number")
# REC2ToWaterPlanLUT$Name <-   c("Hills", "Lakes", "Lowland Hardbed", "Lowland Softbed", "Mountain", "Natural State")[REC2ToWaterPlanLUT$Number]
# 
# #Export as a csv file
# write.table(REC2ToWaterPlanLUT,file=file.path(DataDirectory,NZsegmentToWaterPlanClassLookUpTableFile), sep=",",row.names = FALSE)
# }

#REC data has been sourced from LWP data stores. It has cut down versions of the attribute names, e.g. nzsegment is nzsgmnt. Keep an eye on this when comparing to other data sources that may have the full RECV2 attribute names.
RECReachNetwork <- readOGR(dsn =file.path(GISDataDirectory,REC_rivers),
                           layer = REC_rivers, stringsAsFactors = FALSE)

RECReachNetwork <- spTransform(RECReachNetwork,CRS("+init=epsg:2193") )
#Explicitly set the "headw_dist","nzsegment","headw_dist","TO_NODE","FROM_NODE" attributes to numeric

RECReachNetwork@data[,c("headw_dist","nzsegment","TO_NODE","FROM_NODE")]<- lapply(RECReachNetwork@data[,c("headw_dist","nzsegment","TO_NODE","FROM_NODE")],as.numeric)
#Load the REC2 utility data with lots of useful stuff in it, including river names
load(REC2UtilityFile)   #This provides the REC2Utility data frame
#Cut it down to Southland
SouthlandREC2Utility <- REC2Utility[REC2Utility$Region == "S",]
rm(REC2Utility)

#Load the REC2 "Extra" utility data with lots more useful stuff in it, including upstream high producing exotic pasture (LCDB# Class 40)
load(REC2UtilityExtraFile)   #This provides a data frame called REC2
#Cut it down to Southland, and just the column of interest
SouthlandREC2ExtraUtility <- REC2[REC2$nzsegment %in% SouthlandREC2Utility$nzsegment,c("nzsegment","us_LCDB3_40")]
rm(REC2)
#rename the column to "UpstreamHighProducingExoticPasture"
names(SouthlandREC2ExtraUtility)[2] <- "UpstreamHighProducingExoticPasture"

SouthlandREC2Utility <- join(SouthlandREC2Utility,SouthlandREC2ExtraUtility, type="left")
#Calculate percentage upstream exotic pasture
SouthlandREC2Utility$pctExoticPasture <- SouthlandREC2Utility$UpstreamHighProducingExoticPasture / SouthlandREC2Utility$catAreaKM2 /10000
#Fix the five aberrant values 
SouthlandREC2Utility$pctExoticPasture[SouthlandREC2Utility$pctExoticPasture > 100] <- 100


# #For the REC3 network, need to change the name of some columns for compatibility with functions developed for RECV2
# #nzseg_v3 to nzsegment
# names(RECReachNetwork@data)[which(names(RECReachNetwork@data) == "nzseg_v3")] <- "nzsegment"
# #ups_length to headw_dist
# names(RECReachNetwork@data)[which(names(RECReachNetwork@data) == "ups_length")] <- "headw_dist"

# #For the REC3 network, need to make some columns numeric
# RECReachNetwork@data[,c("Order_","nzsegment","FROM_NODE","TO_NODE")] <- lapply(RECReachNetwork@data[,c("Order_","nzsegment","FROM_NODE","TO_NODE")],as.numeric)

##Add the Environment Southland Water Plan Class to the REC2 data
RECReachNetwork$WaterPlan <- NZsegmentToWaterPlanClassLookUpTable$WaterPlanV1[match(RECReachNetwork$nzsegment, NZsegmentToWaterPlanClassLookUpTable$nzsegment)]

#REstrict it to just the major catchments of interest
#RECReachNetwork <- gIntersection(RECReachNetwork,CompleteDomain,byid =TRUE)

#RECWatersheds <- readOGR(dsn = dirname(REC_Catchments),
#                         layer = basename(REC_Catchments), stringsAsFactors = FALSE)
#RECWatersheds <- spTransform(RECWatersheds,CRS("+init=epsg:2193") )

#Load the mean flow data for the REC V2. This is provided in an rdata file which contains the data frame REC2MeanFlow, with three columns, "nzsegment","QMean", and "us_catarea"
load(REC_MeanFlowFile)

#Load the Southland water quality measurement site data and turn into a spatial data frame
MeasurementSites <- read.table(WaterQualityStationFile,sep=",",stringsAsFactors = FALSE, header=TRUE)
#make sure the nzsegment attribute is numeric
MeasurementSites$nzsegment <- as.numeric(MeasurementSites$nzsegment)
#NOTE the coordinates in the measurement site file are WRONG, so
#Get the coordinates from the downstream coordinates for the site's nzsegment.
MeasurementSites$downcoordX <- RECReachNetwork$downcoordX[match(MeasurementSites$nzsegment,RECReachNetwork$nzsegment)]
MeasurementSites$downcoordY <- RECReachNetwork$downcoordY[match(MeasurementSites$nzsegment,RECReachNetwork$nzsegment)]
MeasurementSites <- SpatialPointsDataFrame(coords = MeasurementSites[,c("downcoordX","downcoordY")], data = MeasurementSites,
                               proj4string = CRS("+init=epsg:2193"))
#Remove any duplicate sites
MeasurementSites <- MeasurementSites[!duplicated(MeasurementSites$nzsegment),]
#Add the TN and TP data
MeasurementSiteData <- read.table(WaterQualityDataFile, sep=",",stringsAsFactors = FALSE, header = TRUE)
TNData <- MeasurementSiteData[MeasurementSiteData$npID=="TN",]
MeasurementSites$'TN Load(kg/yr)'     <- TNData$ExpCoeff[match(MeasurementSites$sID,TNData$sID)] * TNData$CATCHAREA[match(MeasurementSites$sID,TNData$sID)] / 10000
MeasurementSites$'TN Load Lci(kg/yr)' <- TNData$ExpCoeff_Lci[match(MeasurementSites$sID,TNData$sID)] * TNData$CATCHAREA[match(MeasurementSites$sID,TNData$sID)]/ 10000
MeasurementSites$'TN Load Uci(kg/yr)' <- TNData$ExpCoeff_Uci[match(MeasurementSites$sID,TNData$sID)] * TNData$CATCHAREA[match(MeasurementSites$sID,TNData$sID)]/ 10000
TPData <- MeasurementSiteData[MeasurementSiteData$npID=="TP",]
MeasurementSites$'TP Load(kg/yr)'     <- TPData$ExpCoeff[match(MeasurementSites$sID,TPData$sID)] * TNData$CATCHAREA[match(MeasurementSites$sID,TNData$sID)]/ 10000
MeasurementSites$'TP Load Lci(kg/yr)' <- TPData$ExpCoeff_Lci[match(MeasurementSites$sID,TPData$sID)] * TNData$CATCHAREA[match(MeasurementSites$sID,TNData$sID)]/ 10000
MeasurementSites$'TP Load Uci(kg/yr)' <- TPData$ExpCoeff_Uci[match(MeasurementSites$sID,TPData$sID)] * TNData$CATCHAREA[match(MeasurementSites$sID,TNData$sID)]/ 10000

#Load lake sites of interest
LakeSites  <- read.table(LakeSiteFile,sep=",",stringsAsFactors = FALSE, header=TRUE)
LakeSites <- SpatialPointsDataFrame(coords = LakeSites[,c("downcoordX","downcoordY")], data = LakeSites,
                               proj4string = CRS("+init=epsg:2193"))
#make sure the nzsegment attribute is numeric
LakeSites$nzsegment <- as.numeric(LakeSites$nzsegment)
#Set the name of the un named lake to "un-named"
LakeSites@data$LakeName[LakeSites@data$LakeName==" "] <- "unnamed"


#Load the lake polygon layer
Lakes <- readOGR(dsn =file.path(GISDataDirectory,LakePolygonFile),layer = LakePolygonFile, stringsAsFactors = FALSE)
Lakes <- spTransform(Lakes,CRS("+init=epsg:2193") )

#Load the additional subjective site locations
ExtraSites <- readOGR(dsn =file.path(GISDataDirectory,ExtraCASMNodeSiteFile),
                           layer = ExtraCASMNodeSiteFile, stringsAsFactors = FALSE)
ExtraSites <- spTransform(ExtraSites,CRS("+init=epsg:2193") )
ExtraSites$nzsegment <- as.numeric(ExtraSites$nzsegment)

#Load a list of river segments where assessment points are NOT needed.
UnnecesaryAssessmentSites <- read.table(UnnecesaryAssessmentSitesFile,sep=",",stringsAsFactors = FALSE, header=TRUE)

#Load the additional river mouth site locations
RiverMouthSites <- readOGR(dsn =file.path(GISDataDirectory,RiverOutletsFile),
                           layer = RiverOutletsFile, stringsAsFactors = FALSE)
RiverMouthSites <- spTransform(RiverMouthSites,CRS("+init=epsg:2193") )

#Load the estuary site data
EstuarySites <- read.table(file.path(DataDirectory,EstuarySiteFile),header=TRUE,stringsAsFactors = FALSE, sep=",")
#Create a spatial file from it
EstuarySitesSpatial <- SpatialPointsDataFrame(coords = EstuarySites[,c("NZTME","NZTMN")],data = EstuarySites, proj4string = CRS("+init=epsg:2193"))

#Load the Environment Southland Water Plan Classification spatial data
#WaterPlanClassification <- readOGR(dsn = file.path(GISDataDirectory,WaterPlanClassificationFile), layer =WaterPlanClassificationFile, stringsAsFactors = FALSE)
#WaterPlanClassification <- spTransform(WaterPlanClassification,CRS("+init=epsg:2193") )

# #Load the Water Plan classification raster data
#   WaterPlanRaster <- raster(WaterPlanClassificationRasterFile)
#   
#   #reproject to WGS84 for mapping
#   WaterPlanRasterWGS84 <- projectRaster(WaterPlanRaster,crs = CRS("+init=epsg:4326"),method = "ngb")
#   WaterPlanRasterWGS84 <- ratify(WaterPlanRasterWGS84)
#   WaterPlanClassRAT <- levels(WaterPlanRasterWGS84)[[1]]
#   WaterPlanClassRAT$WaterPlanClass <- c("Hills", "Lakes", "Lowland Hardbed", "Lowland Softbed", "Mountain", "Natural State")
#   levels(WaterPlanRasterWGS84)  <- WaterPlanClassRAT

#Load the Maori Culturally important sites
TeAoMaramaSites <- read.csv(TeAoMaramaSitesFile, stringsAsFactors = FALSE, encoding = "UTF-8")
TeAoMaramaSites <- TeAoMaramaSites[!is.na(TeAoMaramaSites$nzsegment) & TeAoMaramaSites$New.site == "Y",]
#Create a spatial file from it, using the upcoordinates from the REC data
TeAoMaramaSites[,c("Easting","Northing")] <- RECReachNetwork@data[match(TeAoMaramaSites$nzsegment,RECReachNetwork$nzsegment), c("upcoordX","upcoordY")]
TeAoMaramaSpatial <- SpatialPointsDataFrame(coords = TeAoMaramaSites[,c("Easting","Northing")], data = TeAoMaramaSites, proj4string = CRS("+init=epsg:2193"))
#Save if you want
#writeOGR(TeAoMaramaSpatial,dsn=GISDataDirectory,layer="TeAoMarama",driver="ESRI Shapefile",overwrite_layer=TRUE)

#Load the point source site data
PointSources <- read.csv(PointSourceSitesFile,stringsAsFactors = FALSE)
#Create a spatial file from it
PointSourcesSpatial <- SpatialPointsDataFrame(coords = PointSources[,c("Easting","Northing")],data = PointSources, proj4string = CRS("+init=epsg:2193"))

#Load the CASM nzsegment override text file. Used to simplify the resulting network
CASMnzsegmentOverrideData <- read.csv(CASMnzsegOverrideFile)

  #Load the Groundwater Management Zone data
GroundwaterZones <- readOGR(dsn =file.path(GISDataDirectory,GroundwaterZonesFile),
                           layer = GroundwaterZonesFile, stringsAsFactors = FALSE)
GroundwaterZones <- spTransform(GroundwaterZones,CRS("+init=epsg:2193") )

#Load the leachrate data if it exists
LeachRateRaster <- stack(LeachRateRasterFile)

#**********************************************************
#If the leach rate raster file is missing or needs to be re-created then use the following:
#Takes 4 minutes at 250 m
# source(file.path(ProjectDirectory,"R/CASM_Southland/LeachRateRasterCreator.R"))
# tic()
# LeachRateRaster <- LeachRateRasterCreator(LanduseData=LanduseShapeFile,
#                                    SoilDrainageData=SoilDrainageShapeFile,
#                                    SlopeClassData=SlopeClassShapeFile,
#                                    PrecipIrrig=PrecipIrrigShapeFile,
#                                    LeachRateData = LeachRateLUTFile,
#                                    Resolution = 250)
# toc()
# #And save it for nexttime
# writeRaster(LeachRateRaster[[1:2]],LeachRateRasterFile,overwrite=TRUE)
# writeRaster(LeachRateRaster[[3:6]],PredictorRasterFile,overwrite=TRUE)
# 
# #******************************************************************

#Load the Physiography-based attenuation estimates
PhsioAttenEstRaster <- stack(PhysiographyBasedAttenuationEstimatesFile)

#**********************************************************
#If the physiography-based attenuation estimates raster file is missing or needs to be re-created then use the following:
#Takes 4 minutes at 250 m
# tic()
# PhsioAttenEstRaster <- CreatePhysiographyAttenuationEstimates(PhysiographicFile = PhysiographicDataFile,
#                                                    Domain = CompleteDomain, 
#                                                    AttenuationLookupTable = PhysiographicAttenuationLookupTableFile)
# toc()
# #And save it for nexttime
# writeRaster(PhsioAttenEstRaster,PhysiographyBasedAttenuationEstimatesFile,overwrite=TRUE)
# 
# #******************************************************************

```

"Correct"the Waiau flows below Manapouri to account for most of the water going out to Doubtful Sound through the power scheme.
Mean annual flow at the Manapouri outlet should be 69 m3s-1 (according to Ton, see email from Ton to Tim Cox cc Tim Kerr on 3 June 2020 at 7:53 am subject Re: FW: Nohoanga site shape file )
```{r}
ManapouriOutlet <- 15266022
OutletFlow<- 69 #m3s-1
#Get all the mainstem reach numbers down the Waiau from the  Lake Manapouri outlet
nextReach <- ManapouriOutlet
MainstemReaches <- c(ManapouriOutlet)
while (length(nextReach) == 1){
  nextReach <- RECReachNetwork$nzsegment[which(RECReachNetwork$FROM_NODE == RECReachNetwork$TO_NODE[RECReachNetwork$nzsegment == nextReach])]
  MainstemReaches <- c(MainstemReaches,nextReach)
}
#Find all the reaches that share a TO_NODE with any of the mainstem reaches
JunctionReaches <- RECReachNetwork$nzsegment[which(RECReachNetwork$TO_NODE %in% RECReachNetwork$TO_NODE[RECReachNetwork$nzsegment %in% MainstemReaches])]
#Remove any that are in the mainstem
TributaryReaches <- JunctionReaches[!JunctionReaches %in% MainstemReaches]

#Starting from the top, meanflow is 69 m3s-1, then 69 + first trib, then 69 + next two tribs etc
upstreamflow <- 0
flow <- OutletFlow
Mainstemflow <- c(OutletFlow)
for(reachIndex in seq(1,length(MainstemReaches))){
  flow <- flow + REC2MeanFlow$QMean[which(REC2MeanFlow$nzsegment==TributaryReaches[reachIndex])]
  Mainstemflow <- c(Mainstemflow,flow)
}
WaiauFlowCorrection <- data.frame(nzsegment = MainstemReaches, QMean = Mainstemflow)
```


Create a bunch of points that represent reaches of sub-catchment confluences over a certain strahler order.
Remove any duplicate sites or sites manually deemed unnecesary as listed in the "unnecesary" file
Add some extra points that have been manually selected and are listed in the "Extrasites" file
```{r}
SubCatchmentConfluenceReaches <- ReachJunctionFinderByOrder(RECReachNetwork@data,OrderThreshold = 5)

SubCatchmentConfluencePoints <- RECReachNetwork@data[RECReachNetwork@data$nzsegment %in% SubCatchmentConfluenceReaches,]
SubCatchmentConfluencePoints <- SubCatchmentConfluencePoints[,c("nzsegment","upcoordX","upcoordY")]
SubCatchmentConfluencePoints$Reason <- "Base of catchment"

#Turn into a spatial dataframe
SubCatchmentConfluencePointsSpatial <- SpatialPointsDataFrame(coords = SubCatchmentConfluencePoints[,c("upcoordX","upcoordY")],
                                                              data = SubCatchmentConfluencePoints[,c("nzsegment","Reason")],
                                                              proj4string = CRS("+init=epsg:2193"))

#Remove any points that already exist in the Measurement site, Lake site, Estuary site, or Outlet site or Te Ao Marama sites
SubCatchmentConfluencePointsSpatial <- SubCatchmentConfluencePointsSpatial[which(!SubCatchmentConfluencePointsSpatial$nzsegment %in% c(MeasurementSites$nzsegment, LakeSites$nzsegment, EstuarySites$nzsegment,RiverMouthSites$nzsegment,TeAoMaramaSites$nzsegment)),]

#Remove any points that are terminal reaches as they have been manually selected in the "RiverMouthSites"
SubCatchmentConfluencePointsSpatial <- SubCatchmentConfluencePointsSpatial[!SubCatchmentConfluencePointsSpatial$nzsegment %in% SouthlandREC2Utility$nzsegment[SouthlandREC2Utility$isTerminal],]

#Remove any sites from the "unnecesary sites" list
SubCatchmentConfluencePointsSpatial <- SubCatchmentConfluencePointsSpatial[!(SubCatchmentConfluencePointsSpatial$nzsegment %in% UnnecesaryAssessmentSites$nzsegment),]

#Keep the points that are not within lakes
SubCatchmentConfluencePointsSpatial <- SubCatchmentConfluencePointsSpatial[is.na(over(SubCatchmentConfluencePointsSpatial,Lakes)[,1]),]

#Add any additional sites from the manually created "ExtraSites"
SubCatchmentConfluencePointsSpatial <- bind(SubCatchmentConfluencePointsSpatial,ExtraSites[which(!ExtraSites$nzsegment %in% SubCatchmentConfluencePointsSpatial$nzsegment),c("nzsegment","Reason")])

#Add the River names
SubCatchmentConfluencePointsSpatial@data <- join(SubCatchmentConfluencePointsSpatial@data,SouthlandREC2Utility[,c("nzsegment","RiverName")],type="left")

#Remove points not within the overall domain
SubCatchmentConfluencePointsSpatial <- SubCatchmentConfluencePointsSpatial[!is.na(SubCatchmentConfluencePointsSpatial %over% CompleteDomain),]

#Save a copy for viewing in QGIS if required
#writeOGR(SubCatchmentConfluencePointsSpatial, file.path(GISDataDirectory,"SubCatchmentJunctionSites"),layer="SubcatchmentJunctionSites",driver="ESRI Shapefile",overwrite_layer=TRUE)
```


From the load sites, point source sites, and water management subzones outlets, create the required network.
!!This doesn't work with REC3!! as all the nzsegment values are REC2 values.
```{r}
#Combine all the points together in a single cohesive data frame
CombinedPoints <- data.frame(nzsegment = numeric(),Type= character(),Name= character(),Comment=character(), stringsAsFactors = FALSE )

MeasurementPoints <- MeasurementSites@data[,c("nzsegment","sID")]
names(MeasurementPoints)[2] <- "Name"
MeasurementPoints$Type <- "Water quality measurement site"

PointSourceSites <- PointSourcesSpatial@data[,c("nzsegment","Source")]
names(PointSourceSites)[2] <- "Name"
PointSourceSites$Type <- "Point Source"

LakePoints <- LakeSites@data[,c("nzsegment","LakeName")]
names(LakePoints)[2] <- "Name"
LakePoints$Type <- "Lake"
LakePoints$Comment <- "Not monitored"
LakePoints$Comment[LakeSites@data$Monitored] <- "Monitored"

EstuaryPoints <- EstuarySitesSpatial@data[,c("nzsegment","Name")]
EstuaryPoints$Type <- "Estuary"

ConfluencePoints <- SubCatchmentConfluencePointsSpatial@data[,c("nzsegment","RiverName","Reason")]
names(ConfluencePoints)[c(2,3)] <- c("Name","Comment")
ConfluencePoints$Type <- "Various"

RivermouthPoints <- RiverMouthSites@data[,c("nzsegment","River")]
names(RivermouthPoints)[2] <- "Name"
RivermouthPoints$Type <- "Rivermouth"

CulturalPoints <- TeAoMaramaSpatial@data[,c("nzsegment","Waterbody")]
names(CulturalPoints)[2] <- "Name"
CulturalPoints$Type <- "Cultural"

CombinedPoints <- rbind.fill(CombinedPoints,MeasurementPoints,PointSourceSites,LakePoints,EstuaryPoints,ConfluencePoints,RivermouthPoints,CulturalPoints)

#Remove any duplicates (there are three that I know of)
CombinedPoints <- CombinedPoints[!duplicated(CombinedPoints$nzsegment),]

#Add Water management class to it
CombinedPoints$WaterPlan <- NZsegmentToWaterPlanClassLookUpTable$WaterPlanV1[match(CombinedPoints$nzsegment, NZsegmentToWaterPlanClassLookUpTable$nzsegment)]


#Get just the assessment points and write to a file
AssessmentPoints <-  CombinedPoints[!CombinedPoints$Type %in% c("Point Source"),]
write.table(AssessmentPoints,file.path(DataDirectory,"CombinedAssessmentPoints.csv"),sep=",",row.names = FALSE)

#AllPoints <- c(MeasurementSites$nzsegment, PointSourceSites$nzsegment, MajorCatchmentOuteltReachesDF$nzsegment)
AllPoints <- CombinedPoints$nzsegment

#Create an REC network that incorporates all points
LoadNetwork <- lapply(AllPoints, function(x) {DownstreamReachFinder(RECNetwork = RECReachNetwork, SourceReach = x)} )
CompleteNetwork <- unlist(LoadNetwork)
CompleteNetwork <- CompleteNetwork[!duplicated(CompleteNetwork)]
CompleteNetwork <- as.numeric(CompleteNetwork)
AllPointsCompleteSpatialNetwork <- RECReachNetwork[RECReachNetwork$nzsegment %in% CompleteNetwork,]
#and label it
NetworkLabelList <- NetworkLabeller(RECV2Network = AllPointsCompleteSpatialNetwork)
SegmentToLabelLookUpTable <- do.call(rbind,NetworkLabelList)
AllPointsCompleteSpatialNetwork@data$Label <- SegmentToLabelLookUpTable$name[match(AllPointsCompleteSpatialNetwork@data$nzsegment,SegmentToLabelLookUpTable$nzsegment)]

#For CASM purposes the network can be simplified. This is achieved by overiding the nzsegment number with a "CASMnzsegment" number if it exists from within the CASMnzsegmentOverideForLocation.csv" file
CASMAllPoints <- AllPoints
IndicesOfnzsegmentsToUpdate <- which(CASMAllPoints %in% as.character(CASMnzsegmentOverrideData$nzsegment))
CASMAllPoints[IndicesOfnzsegmentsToUpdate] <- as.character(CASMnzsegmentOverrideData$CASMnzsegment)

LoadNetwork <- lapply(CASMAllPoints, function(x) {DownstreamReachFinder(RECNetwork = RECReachNetwork, SourceReach = x)} )
CompleteNetwork <- unlist(LoadNetwork)
CompleteNetwork <- CompleteNetwork[!duplicated(CompleteNetwork)]
CompleteNetwork <- as.numeric(CompleteNetwork)

CompleteSpatialNetwork <- RECReachNetwork[RECReachNetwork$nzsegment %in% CompleteNetwork,]

```


By request of Ton.

Plot a histogram showing percentage of segments (for strahler order 3 and above) that are in 10 bins of % upstream exotic grassland
On the same histogram show the percentage of location points in each bin

Then repeat for upstream catchment area

Then repeat for Water Plan class
```{r, fig.width=12, fig.height = 12}
#Get all the REC reaches in strahler order 3 and above
RECOrder3andAbove <- RECReachNetwork[RECReachNetwork@data$StreamOrde >= 3,]

#Limit to sites within the overall domain
RECOrder3andAbove <- RECOrder3andAbove[!is.na(RECOrder3andAbove %over% CompleteDomain),]

#Add the pctExoticPasture attribute from the SouthlandREC2Utility data
RECOrder3andAbove@data <- join(RECOrder3andAbove@data,SouthlandREC2Utility[,c("pctExoticPasture","nzsegment")],type="left")

#Add the catchment name as an attribute
RECOrder3andAbove$Catchments <- as.character(unlist(RECOrder3andAbove %over% MajorCatchments))

#There are a few in New River Estuary and Invercargill area that are outside the Invercargill FMU boundary, but only because the boundary doesn't include the estuary
RECOrder3andAbove$Catchments[which(is.na(RECOrder3andAbove$Catchments))] <- "Oreti & Invercargill Catchments"

#These are all the "Network" sites, so I'll call them that in an attribute called "What
RECOrder3andAbove@data$What <- "Network"

#And just extract the dataframe for the graphing
GraphDataFortheCompleteNetwork <- RECOrder3andAbove@data[,c("nzsegment","CUM_AREA","WaterPlan","Catchments","pctExoticPasture","What")]

#Add an attribute which has the total number of segments in the class
GraphDataFortheCompleteNetwork$TotalNo <- nrow(GraphDataFortheCompleteNetwork)

#Add an attribute which has the total number of segments in the class in each catchment
TotalReachesInEachCatchment <- table(GraphDataFortheCompleteNetwork$Catchments)
GraphDataFortheCompleteNetwork$TotalInEachCatchment <- as.vector(TotalReachesInEachCatchment[GraphDataFortheCompleteNetwork$Catchments])

#Just in case, remove any rows that aren't complete (I think there is one missing the pstUpstream pasture attribute
GraphDataFortheCompleteNetwork <- GraphDataFortheCompleteNetwork[complete.cases(GraphDataFortheCompleteNetwork),]

#Create a subset of these that are associated with CASM locations
GraphDataForLocations <- GraphDataFortheCompleteNetwork[which(GraphDataFortheCompleteNetwork$nzsegment %in% AllPoints),]

#And re-label the "What" attribute to "Locations"
GraphDataForLocations$What <- "Locations"

#Update the TotalNo to match the number of locations, and the total number in each catchment
GraphDataForLocations$TotalNo <- nrow(GraphDataForLocations)
TotalLocationsInEachCatchment <- table(GraphDataForLocations$Catchments)
GraphDataForLocations$TotalInEachCatchment <- as.vector(TotalLocationsInEachCatchment[GraphDataForLocations$Catchments])

#Rbind the full network and the locations
GraphData <- rbind(GraphDataFortheCompleteNetwork,GraphDataForLocations)

#Convert the catchment area to km2
GraphData$CUM_AREA <- round(GraphData$CUM_AREA / 1000000,1)

#Rename the attributes of interest to make the automatic graph labelling a bit more intuitive
GraphData <- rename(GraphData, c("CUM_AREA"="Catchment Area (km2)",
                    "pctExoticPasture"="Percentage of catchment in high producing pasture",
                    "WaterPlan"="Water Plan Classes"))

#Initialise an empty plot list
PlotList <- list()

AttributesOfInterest <- c("Catchment Area (km2)","Percentage of catchment in high producing pasture")
for (AttributeToBePlotted in AttributesOfInterest){

FullDomainPlot <- ggplot(GraphData, aes(x=GraphData[,AttributeToBePlotted],y=stat(count) * 100,fill=What,weight=1/TotalNo)) + geom_histogram(bins=10,colour="grey",position="dodge") + labs(fill="", title = "All catchments",x = AttributeToBePlotted, y = "Percentage of total")

CatchmentPlot <- ggplot(GraphData, aes(x=GraphData[,AttributeToBePlotted],y=stat(count) * 100,fill=What,weight=1/TotalInEachCatchment))+ geom_histogram(bins=10,colour="grey",position="dodge") + labs(fill="", x = AttributeToBePlotted, y = "Percentage of total") + facet_wrap(. ~Catchments,ncol=2)

PlotList <- c(PlotList,list(FullDomainPlot),list(CatchmentPlot))
}

WaterPlanFullDomainPlot <- ggplot(GraphData, aes(x=GraphData[,"Water Plan Classes"],y=stat(count) * 100,fill=What,weight=1/TotalNo)) + geom_bar(colour="grey",position="dodge") + labs(fill="",title = "All catchments", x = "Water Plan Classes", y = "Percentage of total") 

WaterPlanByCatchmentPlot <- ggplot(GraphData, aes(x=GraphData[,"Water Plan Classes"],y=stat(count) * 100,fill=What,weight=1/TotalInEachCatchment))+ geom_bar(colour="grey",position="dodge") + labs(fill="", x = "Water Plan Classes", y = "Percentage of total") + theme(axis.text.x = element_text(angle = 45, hjust=1))+ facet_wrap(. ~Catchments,ncol=2)

PlotList <- c(PlotList,list(WaterPlanFullDomainPlot),list(WaterPlanByCatchmentPlot))

library(gridExtra)

# Three pages of plots in one PDF file
{
pdf(file.path(DataDirectory,"CASM Node location representativeness.pdf"), 8.27, 11.69)
for (i in seq(1, length(PlotList), 2)) {
grid.arrange(PlotList[[i]],
             PlotList[[i+1]],
             nrow=3,
             layout_matrix = rbind(1,2,2,2))

}
dev.off()
}


```



Then create a tributary table ready for CASM
**** This needs an Outlet Reach Name lookup table to be manually prepared ****
```{r}
#Label everything
NetworkLabelList <- NetworkLabeller(RECV2Network = CompleteSpatialNetwork)
#Add the tributary labels to the network
SegmentToLabelLookUpTable <- do.call(rbind,NetworkLabelList)
CompleteSpatialNetwork@data$Label <- SegmentToLabelLookUpTable$name[match(CompleteSpatialNetwork@data$nzsegment,SegmentToLabelLookUpTable$nzsegment)]

#add the Southland freshwater management unit name
CompleteSpatialNetwork$FMU <- unlist(CompleteSpatialNetwork %over% MajorCatchments)

#add the CASM "basin"/model domain
CASMBasinLookupTable <- read.table(CASMBasinLookupTableFile,sep=",",stringsAsFactors = FALSE, header = TRUE)
CompleteSpatialNetwork@data$CASMBasin <- CASMBasinLookupTable$CASM_Basin[match(CompleteSpatialNetwork$FMU,CASMBasinLookupTable$SouthlandFMU)]

#Add the prefixed labels to the network
#SegmentToPrefixedLabelLookUpTable <- ReachLabeler(NetworkLabelList, OutletReachNames)
#CompleteSpatialNetwork@data$PrefixedLabel <- SegmentToPrefixedLabelLookUpTable$Prefixedlabel[match(CompleteSpatialNetwork@data$nzsegment,SegmentToPrefixedLabelLookUpTable$nzsgmnt)]

#Save the network as a spatial file
#writeOGR(CompleteSpatialNetwork, dsn=GISDataDirectory,layer="CASM-StreamNetwork-namedV2", driver="ESRI Shapefile",overwrite_layer=TRUE)

TributaryConnectionTable <- TributaryConnectionCreator(RECNetwork = CompleteSpatialNetwork, TributaryLabelList = NetworkLabelList)

#************************************
#Note that the Eglinton location is not calculated correctly, but the result works out OK. This was achieved by messing with the labelling of the reaches.


#Add the CASM Basin details
TributaryConnectionTable$CASMBasin <- CompleteSpatialNetwork$CASMBasin[match(TributaryConnectionTable$nzsegment,CompleteSpatialNetwork$nzsegment)]
```

Then create a point source table ready for CASM,
a measurement site table ready for CASM,
and a diffuse inputs table ready for CASM
```{r}
#Create a dataframe of just the nzsegment number and the site name
PointSourceNodes <- PointSourcesSpatial@data[,c("Source","nzsegment")]

#Update the nzsegment numbers to use the CASM override nzsegment numbers
#PointSourceNodesOriginalnzsegment <- PointSourceNodes$nzsegment
IndicesOfnzsegmentsToUpdate <- which(PointSourceNodes$nzsegment %in% CASMnzsegmentOverrideData$nzsegment)
PointSourceNodes$nzsegment[IndicesOfnzsegmentsToUpdate] <- CASMnzsegmentOverrideData$CASMnzsegment[match(PointSourceNodes$nzsegment[IndicesOfnzsegmentsToUpdate],CASMnzsegmentOverrideData$nzsegment)]

#Standardise the column names so that it matches the expected format in the CASMNodeTablePreparer() function
names(PointSourceNodes) <- c("NodeName","nzsegment")

#OriginalnzsegmentLUT <- as.data.frame(cbind(Original=PointSourceNodesOriginalnzsegment,Name = PointSourceNodes$NodeName))

#Prepare the CASM table with the bonus nzsegment column
PointSourceTable <- CASMNodeTablePreparer(CASMRECNetwork = CompleteSpatialNetwork, NetworkLabelList = NetworkLabelList, TributaryConnectionTable = TributaryConnectionTable,CASMNodes = PointSourceNodes )

#rename the columns to match the CASM requirements
names(PointSourceTable) <- c("nzsegment","Point Source Name","Receiving Stream","Location (km)")

#OriginalnzsegmentLUT <- merge(PointSourceTable,OriginalnzsegmentLUT,by.x="Point Source Name",by.y="Name",all.x=TRUE) 
#Need to add the point source load to the table
PointSourceTable$"N Annual Load (kg/yr)" <- round(PointSourcesSpatial$TN__t_y_[match(PointSourceTable$"Point Source Name",PointSourcesSpatial$Source)]*1000,0)
PointSourceTable$"P Annual Load (kg/yr)" <- round(PointSourcesSpatial$TP__t_y_[match(PointSourceTable$"Point Source Name",PointSourcesSpatial$Source)]*1000,0)

#Make the NA values 0
PointSourceTable$"N Annual Load (kg/yr)"[is.na(PointSourceTable$"N Annual Load (kg/yr)")] <- 0
PointSourceTable$"P Annual Load (kg/yr)"[is.na(PointSourceTable$"P Annual Load (kg/yr)")] <- 0

#Add the CASM Basin details
PointSourceTable$CASMBasin <- CompleteSpatialNetwork$CASMBasin[match(PointSourceTable$nzsegment,CompleteSpatialNetwork$nzsegment)]
```



#Repeat for the measurement sites. Note that these do not have any CASM override nzsegments
```{r}
MeasurementSiteNodes <- MeasurementSites[,c("sID","nzsegment")]
names(MeasurementSiteNodes) <- c("NodeName","nzsegment")
MeasurementSiteTable <- CASMNodeTablePreparer(CASMRECNetwork = CompleteSpatialNetwork, NetworkLabelList = NetworkLabelList, TributaryConnectionTable = TributaryConnectionTable,CASMNodes= MeasurementSiteNodes)

#rename the columns to match the CASM conventions
names(MeasurementSiteTable) <- c("nzsegment","Site Name or No","Target Stream","Downstream Location (km)")

#Add the mean annual flow to the table
MeasurementSiteTable$"Mean flow (m3/s)" <- round(REC2MeanFlow$QMean[match(MeasurementSiteTable$nzsegment, REC2MeanFlow$nzsegment)],1)

#Correct the Waiau flows for Manapori operation
WaiauIndices <- which(MeasurementSiteTable$nzsegment %in% WaiauFlowCorrection$nzsegment)
MeasurementSiteTable$`Mean flow (m3/s)`[WaiauIndices] <- WaiauFlowCorrection$QMean[match(MeasurementSiteTable$nzsegment[WaiauIndices],WaiauFlowCorrection$nzsegment)] 

#Add the CASM Basin details
MeasurementSiteTable$CASMBasin <- CompleteSpatialNetwork$CASMBasin[match(MeasurementSiteTable$nzsegment,CompleteSpatialNetwork$nzsegment)]

#Add a variety of other fields from the Measurement Site data
MeasurementSiteTable$'TN Load (kg/yr)'     <- round(MeasurementSites$'TN Load(kg/yr)'[match(MeasurementSiteTable$"Site Name or No", MeasurementSites$sID)],1)
MeasurementSiteTable$'TN Load Lci (kg/yr)' <- round(MeasurementSites$'TN Load Lci(kg/yr)'[match(MeasurementSiteTable$"Site Name or No", MeasurementSites$sID)],1)
MeasurementSiteTable$'TN Load Uci (kg/yr)' <- round(MeasurementSites$'TN Load Uci(kg/yr)'[match(MeasurementSiteTable$"Site Name or No", MeasurementSites$sID)],1)

MeasurementSiteTable$'TP Load (kg/yr)'     <- round(MeasurementSites$'TP Load(kg/yr)'[match(MeasurementSiteTable$"Site Name or No", MeasurementSites$sID)],1)
MeasurementSiteTable$'TP Load Lci (kg/yr)' <- round(MeasurementSites$'TP Load Lci(kg/yr)'[match(MeasurementSiteTable$"Site Name or No", MeasurementSites$sID)],1)
MeasurementSiteTable$'TP Load Uci (kg/yr)' <- round(MeasurementSites$'TP Load Uci(kg/yr)'[match(MeasurementSiteTable$"Site Name or No", MeasurementSites$sID)],1)
```

#Repeat for all assessment points (except the measurement points that have already been done)
```{r}
AssessmentSites <- CombinedPoints[!CombinedPoints$Type %in% c("Point Source","Water quality measurement site"),]

AssessmentSiteNodes <- AssessmentSites[,c("Name","nzsegment","Type","Comment")]
names(AssessmentSiteNodes)[1] <- "NodeName"
#Any sites missing names, use their river reach names, but need to use the all-points network, not the CASM refined network.
#The CASM refined network doesn't have all the reaches, so not everything can be named. For the small side tributaries this gives them the right name. If it was ignored and the naming was done after the CASM override was done, then the names would transfer to the overriden reach which is often a large river, so you wouldn't really know where it was.
AssessmentSiteNodes$NodeName[is.na(AssessmentSiteNodes$NodeName)] <- AllPointsCompleteSpatialNetwork$Label[match(AssessmentSiteNodes$nzsegment[is.na(AssessmentSiteNodes$NodeName)],AllPointsCompleteSpatialNetwork$nzsegment)]
#Any "unnamed" lakes name with the Lake ID
AssessmentSiteNodes$NodeName[AssessmentSiteNodes$NodeName=="unnamed"] <- paste("LakeID: ",LakeSites$LID[match(AssessmentSiteNodes$nzsegment[AssessmentSiteNodes$NodeName=="unnamed"],LakeSites$nzsegment)])

#Get the mean flow for all the assessment point. Again this needs to be done on the original points as sometimes the override segments are on a large river with large flows that are wrong for the diffuse area.
#Add the mean annual flow to the table
MeanFlows <- REC2MeanFlow[match(AssessmentSiteNodes$nzsegment, REC2MeanFlow$nzsegment),c("nzsegment","QMean")]

#Update with the modified Waiau flows
WaiauIndices <- which(MeanFlows$nzsegment %in% WaiauFlowCorrection$nzsegment)
MeanFlows$QMean[WaiauIndices] <- WaiauFlowCorrection$QMean[match(MeanFlows$nzsegment[WaiauIndices],WaiauFlowCorrection$nzsegment)]

#Add a column with the CASM override nzsegments in it
MeanFlows$CASMnzsegment <- MeanFlows$nzsegment
IndicesOfnzsegmentsToUpdate <- which(MeanFlows$nzsegment %in% CASMnzsegmentOverrideData$nzsegment)
MeanFlows$CASMnzsegment[IndicesOfnzsegmentsToUpdate] <- CASMnzsegmentOverrideData$CASMnzsegment[match(MeanFlows$nzsegment[IndicesOfnzsegmentsToUpdate],CASMnzsegmentOverrideData$nzsegment)]
#Aggregate flows to common CASMoverride nzsegments
CASMOverrideTotalFlow <- aggregate(MeanFlows$QMean, by = list(MeanFlows$CASMnzsegment), FUN= sum)

#Update the nzsegment numbers to use the CASM override nzsegment numbers
IndicesOfnzsegmentsToUpdate <- which(AssessmentSiteNodes$nzsegment %in% CASMnzsegmentOverrideData$nzsegment)
AssessmentSiteNodes$nzsegment[IndicesOfnzsegmentsToUpdate] <- CASMnzsegmentOverrideData$CASMnzsegment[match(AssessmentSiteNodes$nzsegment[IndicesOfnzsegmentsToUpdate],CASMnzsegmentOverrideData$nzsegment)]

#and only keep one node for each segment
AssessmentSiteNodes <- AssessmentSiteNodes[!duplicated(AssessmentSiteNodes$nzsegment),]

AssessmentSiteTable <- CASMNodeTablePreparer(CASMRECNetwork = CompleteSpatialNetwork, NetworkLabelList = NetworkLabelList, TributaryConnectionTable = TributaryConnectionTable,CASMNodes= AssessmentSiteNodes)

#rename the columns to match the CASM conventions
names(AssessmentSiteTable) <- c("nzsegment","Site Name or No","Target Stream","Downstream Location (km)")

#Add the aggregated flows to the dataframe
AssessmentSiteTable$"Mean flow (m3/s)" <- round(CASMOverrideTotalFlow$x[match(AssessmentSiteTable$nzsegment,CASMOverrideTotalFlow$Group.1)],1)

#Update the site name to combine the nzsegment and the existing site name
AssessmentSiteTable$`Site Name or No` <- paste0(AssessmentSiteTable$`Site Name or No`,"-",AssessmentSiteTable$nzsegment)

#Add the CASM Basin details
AssessmentSiteTable$CASMBasin <- CompleteSpatialNetwork$CASMBasin[match(AssessmentSiteTable$nzsegment,CompleteSpatialNetwork$nzsegment)]
```


#Repeat for diffuse inputs. This is a special case, because once the points have been found, they need to be joined with all the different landuse varieties
```{r}
DiffuseSites <- CombinedPoints[!CombinedPoints$Type %in% c("Point Source"),]

DiffuseSiteNodes <- DiffuseSites[,c("Name","nzsegment","Type","Comment")]
names(DiffuseSiteNodes)[1] <- "NodeName"

#Any sites missing names, use their river reach names
DiffuseSiteNodes$NodeName[is.na(DiffuseSiteNodes$NodeName)] <- AllPointsCompleteSpatialNetwork$Label[match(DiffuseSiteNodes$nzsegment[is.na(DiffuseSiteNodes$NodeName)],AllPointsCompleteSpatialNetwork$nzsegment)]

#Any "unnamed" lakes name with the Lake ID
DiffuseSiteNodes$NodeName[DiffuseSiteNodes$NodeName=="unnamed"] <- paste("LakeID: ",LakeSites$LID[match(DiffuseSiteNodes$nzsegment[DiffuseSiteNodes$NodeName=="unnamed"],LakeSites$nzsegment)])

#Save a copy of the nzsegments in case it is needed to recreate the DiffuseLoadSourceAreas spatial file
Diffusenzsegments <- as.numeric(DiffuseSiteNodes$nzsegment)

#Update the nzsegment with the CASM override nzsegments and restrict the rows to the first instance of each
IndicesOfnzsegmentsToUpdate <- which(DiffuseSiteNodes$nzsegment %in% CASMnzsegmentOverrideData$nzsegment)
DiffuseSiteNodes$nzsegment[IndicesOfnzsegmentsToUpdate] <- CASMnzsegmentOverrideData$CASMnzsegment[match(DiffuseSiteNodes$nzsegment[IndicesOfnzsegmentsToUpdate],CASMnzsegmentOverrideData$nzsegment)]

#and only keep one node for each segment
DiffuseSiteNodes <- DiffuseSiteNodes[!duplicated(DiffuseSiteNodes$nzsegment),]

DiffuseSiteTable <- CASMNodeTablePreparer(CASMRECNetwork = CompleteSpatialNetwork, NetworkLabelList = NetworkLabelList, TributaryConnectionTable = TributaryConnectionTable,CASMNodes= DiffuseSiteNodes)

#rename the columns to match the CASM conventions
names(DiffuseSiteTable) <- c("nzsegment","Site Name or No","Target Stream","Downstream Location (km)")




# #Add the mean annual flow to the table
# DiffuseSiteTable$"Mean flow (m3/s)" <- round(REC2MeanFlow$QMean[match(DiffuseSiteTable$nzsegment, REC2MeanFlow$nzsegment)],1)
# 
# #Update with the modified Waiau flows
# WaiauIndices <- which(DiffuseSiteTable$nzsegment %in% WaiauFlowCorrection$nzsegment)
# DiffuseSiteTable$`Mean flow (m3/s)`[WaiauIndices] <- WaiauFlowCorrection$QMean[match(DiffuseSiteTable$nzsegment[WaiauIndices],WaiauFlowCorrection$nzsegment)] 

#Now it is necesary to prepare the actual diffuse data for the source area of each diffuse source point
#Load the source areas file if it has been pre-prepared. If it hasn't manually check that it should be. Note that this takes about 15 minutes!
DiffuseSourceAreasOK <- FALSE
if(file.exists(DiffuseLoadSourceAreasFile)) {
  DiffuseLoadSourceAreas <- st_read(DiffuseLoadSourceAreasFile)
  #Check that it is correct for the current Diffuse points
  DiffuseSourceAreasOK <- identical(as.integer(sort(unique(Diffusenzsegments))),as.integer(sort(unique(DiffuseLoadSourceAreas$nzsegment))))
}
#If the existing source areas doesn't match the current Diffuse points, or if the file didn't even exist, re-create it
if (!DiffuseSourceAreasOK) {
  invisible(readline(prompt="Press [enter] to agree to generation of the Diffuse load source areas. This takes 15 minutes!"))
  if(!exists("RECWatersheds")) {
  RECWatersheds <- readOGR(dsn = dirname(REC_Catchments),
                         layer = basename(REC_Catchments))
  RECWatersheds <- spTransform(RECWatersheds,CRS("+init=epsg:2193") )
  }
  DiffuseLoadSourceAreas <- CASMNodeSourceAreaGenerator(RECWatersheds = RECWatersheds,RECNetwork = RECReachNetwork@data, CASMNodes = Diffusenzsegments)
  #Save a copy for later
  st_write(DiffuseLoadSourceAreas,DiffuseLoadSourceAreasFile, append=FALSE)
}

#Create an intersection of the Diffuse source area and landuse data by using raster maths.
#Load the landuse raster data
LandUseRaster <- stack(PredictorRasterFile)[[1]]
#While we're here create a lookup table to the landuse classes
LanduseLUT <- levels(LandUseRaster)[[1]]

#rasterize the diffuse source area spatial data, aligning to the Landuse data
DiffuseSourceRaster <- rasterize(DiffuseLoadSourceAreas, LandUseRaster, "nzsegment")

#Calculate a new raster by multiplying the DiffuseSourceArea by 1000, then adding the landuse class.
#This leads to 88888888888088, 888888888088 etc. to represent the unique nzsegment and landuse areas. The last three numbers are the landuse code. The first 8 numbers are the nzsegment. This needs to be an integer to enable generating a raster attribute table.
DiffuseSourceLanduse <- (DiffuseSourceRaster * 1000) + LandUseRaster
#Need to add a RAT
  #Add a raster attribute table which labels the values
  DiffuseSourceLanduse <- ratify(DiffuseSourceLanduse)
  rat <- levels(DiffuseSourceLanduse)[[1]]
  #rat$DiffuseSourceLanduse <- levels(PrecipIrrigSpatial@data$Precip2)
  levels(DiffuseSourceLanduse) <- rat

#Now need to get the leach rates for each of the nzsegment-landuse areas.
#Load the Leachrate Data
LeachRateRaster <- stack(LeachRateRasterFile)
#Get the total nitrogen leach rates for each unique combination of source area and land use
DiffuseLeachRateData <- DiffuseLoadTableCreator(ZoneLanduseLUCRaster = DiffuseSourceLanduse,LeachRates = LeachRateRaster[[1]])
#rename the leach rate column to be explicitly for total nitrogen (TN)
DiffuseLeachRateData <-dplyr::rename(DiffuseLeachRateData,TN_LeachRate = LeachRate)

#Add the total phosphate leach rates
DiffuseLeachRateData$TP_LeachRate <- DiffuseLoadTableCreator(ZoneLanduseLUCRaster = DiffuseSourceLanduse,LeachRates = LeachRateRaster[[2]])$LeachRate

#Do the same for the physiography-based attenuation estimates. I can use the same function, but different raster input
DiffuseLeachRateData$TN_AttEst <- DiffuseLoadTableCreator(ZoneLanduseLUCRaster = DiffuseSourceLanduse,LeachRates = PhsioAttenEstRaster[[1]])$LeachRate
DiffuseLeachRateData$TP_AttEst <- DiffuseLoadTableCreator(ZoneLanduseLUCRaster = DiffuseSourceLanduse,LeachRates = PhsioAttenEstRaster[[2]])$LeachRate

#discombobulate the combined nzsegmentlanduse codes into nzsegment. landuse code and landuse class
DiffuseLeachRateData$nzsegment <- DiffuseLeachRateData$CombinedClassNameLevel %/% 1000
DiffuseLeachRateData$landuseCode <- DiffuseLeachRateData$CombinedClassNameLevel %% 1000
DiffuseLeachRateData$landuse <- LanduseLUT$category[match(DiffuseLeachRateData$landuseCode,LanduseLUT$ID)]

#Now it is time to use the CASM override nzsegments and to aggregate the leach rates accordingly
DiffuseLeachRateData$nzsegmentV0   <- DiffuseLeachRateData$nzsegment
DiffuseLeachRateData$CASMnzsegment <- DiffuseLeachRateData$nzsegment
IndicesOfnzsegmentsToUpdate <- which(DiffuseLeachRateData$nzsegment %in% CASMnzsegmentOverrideData$nzsegment)
DiffuseLeachRateData$CASMnzsegment[IndicesOfnzsegmentsToUpdate] <- CASMnzsegmentOverrideData$CASMnzsegment[match(DiffuseLeachRateData$nzsegment[IndicesOfnzsegmentsToUpdate],CASMnzsegmentOverrideData$nzsegment)]
DiffuseLeachRateData$nzsegment     <- DiffuseLeachRateData$CASMnzsegment

#add in the name of the receiving stream, the discharge location and the node name
DiffuseLeachRateData <- merge(DiffuseLeachRateData,DiffuseSiteTable)

#Create a node name that includes the nzsegment, the site name and the landuse
DiffuseLeachRateData$'NodeName' <- paste0(DiffuseLeachRateData$`Site Name or No`,"-",DiffuseLeachRateData$nzsegment,"-",DiffuseLeachRateData$landuse)

#Next bit needs to be re-factored
#Now aggregate on any common NodeName's .This is required because the CASM overide has lumped together some sites, mainly the estuary sites.
DiffuseAgg      <- aggregate(DiffuseLeachRateData$Hectares,list(DiffuseLeachRateData$`NodeName`),FUN=sum)
names(DiffuseAgg) <- c("NodeName","Hectares")
DiffuseAggTN    <- ddply(DiffuseLeachRateData, .(NodeName), function(x) data.frame(TN_LeachRate=weighted.mean(x$TN_LeachRate, x$Hectares)))
DiffuseAggTNAtt <- ddply(DiffuseLeachRateData, .(NodeName), function(x) data.frame(TN_AttEst=weighted.mean(x$TN_AttEst, x$Hectares)))
DiffuseAggTP    <- ddply(DiffuseLeachRateData, .(NodeName), function(x) data.frame(TP_LeachRate=weighted.mean(x$TP_LeachRate, x$Hectares)))
DiffuseAggTPAtt <- ddply(DiffuseLeachRateData, .(NodeName), function(x) data.frame(TP_AttEst=weighted.mean(x$TP_AttEst, x$Hectares)))

#Extract the useful data for the unique NodeNames
DiffuseLeachRateDataUnique <- DiffuseLeachRateData[!duplicated(DiffuseLeachRateData$NodeName),c("NodeName","nzsegment","Site Name or No","Target Stream","Downstream Location (km)")]
DiffuseLeachRateDataUnique <- merge(DiffuseLeachRateDataUnique,DiffuseAgg,by="NodeName")
DiffuseLeachRateDataUnique <- merge(DiffuseLeachRateDataUnique,DiffuseAggTN,by="NodeName")
DiffuseLeachRateDataUnique <- merge(DiffuseLeachRateDataUnique,DiffuseAggTNAtt,by="NodeName")
DiffuseLeachRateDataUnique <- merge(DiffuseLeachRateDataUnique,DiffuseAggTP,by="NodeName")
DiffuseLeachRateDataUnique <- merge(DiffuseLeachRateDataUnique,DiffuseAggTPAtt,by="NodeName")

#Add the CASM Basin details
DiffuseLeachRateDataUnique$CASMBasin <- CompleteSpatialNetwork$CASMBasin[match(DiffuseLeachRateDataUnique$nzsegment,CompleteSpatialNetwork$nzsegment)]

#I now need to adjust the locations of all the different landuse options for a single diffuse source point so that they are not all on exactly the same spot.
#Work along each Diffuse point areas, get all the landuse classes, and increment the locations by 0.1 km
DiffuseLeachRateDataUnique$AdjustedTriblocn <- DiffuseLeachRateDataUnique$'Downstream Location (km)'
UniqueSourceAreas <- unique(DiffuseLeachRateDataUnique$nzsegment)
for(SourceAreaIndex in seq_along(UniqueSourceAreas)) {
  #get the SourceArea of interest
  SourceArea <- UniqueSourceAreas[SourceAreaIndex]
  
  #Get all the landuse classes in the SourceArea
  RowsOfInterest <- which(DiffuseLeachRateDataUnique$nzsegment == SourceArea)
  DiffuseLeachRateDataUnique$AdjustedTriblocn[RowsOfInterest] <- DiffuseLeachRateDataUnique$'Downstream Location (km)'[RowsOfInterest] + seq(0,by = 0.01, length.out = length(RowsOfInterest))
}

#Copy it all to a new dataframe
DiffuseInputsSiteExtendedTable <- DiffuseLeachRateDataUnique

#rename the columns to match the CASM conventions
names(DiffuseInputsSiteExtendedTable) <- c("Node Name","nzsegment","Site Name or No.","Receiving Stream","Original location (km)","Land Area (ha)","TN Export Coeff (kg/ha/yr)","TN Physiographic-based attenuation scale estimate","TP Export Coeff (kg/ha/yr)","TP Physiographic-based attenuation scale estimate","CASMBasin","Discharge Location (km)")

```


An overview plot is required showing the various points and the underlying relevant spatial data.
This plot is pre-modelling to share with the project  participants so that they can check that the points are in the right place.
Chlopleth mapping is from here https://rstudio.github.io/leaflet/choropleths.html
Raster mapping is from here https://stackoverflow.com/questions/59110756/failed-to-add-a-categorical-legend-in-leaflet-in-r-using-addlegendlabels

Speed improvements were undertaken following https://stackoverflow.com/questions/44356224/leaflet-shiny-integration-slow
```{r}


#RECForMaps <- RECReachNetwork[(sqrt(RECReachNetwork@data$CUM_AREA)/10000 > 1) | (RECReachNetwork@data$nzsegment %in% CompleteNetwork),]
#RECForMaps$LineWidthPixels <- pmax(1,as.integer(sqrt(RECForMaps@data$CUM_AREA)/10000)) #SCale the line width, with a minimum of 1 pixel

#Just get the network needed for the map. For REC3, the headw_dist divisor is 2000, for RECV2 it is 200, so need to edit this.
#RECForMaps <- RECReachNetwork[(sqrt(RECReachNetwork@data$headw_dist)/100 > 1) | (RECReachNetwork@data$nzsegment %in% CompleteNetwork),]
#RECForMaps <- RECReachNetwork[(RECReachNetwork@data$nzsegment %in% CompleteNetwork),]
RECForMaps <- CompleteSpatialNetwork
RECForMaps$LineWidthPixels <- pmax(4,as.integer(sqrt(RECForMaps@data$headw_dist)/100)) #SCale the line width, with a minimum of 1 pixel

RECForMaps <- RECForMaps[,c("LineWidthPixels","WaterPlan","Label","nzsegment")]
RECForMaps$WaterPlan <- as.factor(RECForMaps$WaterPlan)
RECForMaps <- ms_simplify(RECForMaps)



#Reproject the vector spatial data to the maps projection ready for plotting
#Note that the raster data was reprojected when it was loaded.
#SpatialData <- list(MeasurementSites=MeasurementSitesSpatial, PointSourceSites=PointSourceSitesSpatial,
#                    SubZones=SubZonePolygons,RiverNetwork=CompleteSpatialNetwork)
SpatialData <- list(MeasurementSites=MeasurementSites,LakeSites=LakeSites,EstuarySites=EstuarySitesSpatial,SubCatchmentSites=SubCatchmentConfluencePointsSpatial,RiverMouthSites=RiverMouthSites, RiverNetwork=RECForMaps,MajorCatchments=MajorCatchments,GroundwaterZones=GroundwaterZones, PointSourceSites=PointSourcesSpatial, TeAoMaramaSites=TeAoMaramaSpatial,DiffuseSourceAreas = as(DiffuseLoadSourceAreas,"Spatial"))
MapData <- lapply(SpatialData, spTransform,CRS("+init=epsg:4326"))

if(!exists("PhysiographyRasterWGS84"))PhysiographyRasterWGS84 <- CreatePhysiography(SourceFile = PhysiographicDataFile,Domain = CompleteDomain)
MapData$Physiography <- PhysiographyRasterWGS84
#MapData$WaterPlan <- WaterPlanRasterWGS84

MeasurementSiteLabels <- lapply(seq(nrow(MapData$MeasurementSites@data)), function(i) {
  paste0("Measurement site:", '</br>', 
          MapData$MeasurementSites@data[i, "SiteDescription"], 
         '</br>REC#:',MapData$MeasurementSites@data[i, "nzsegment"]) 
})

EstuarySiteLabels <- lapply(seq(nrow(MapData$EstuarySites@data)), function(i) {
  paste0("Estuary site:", '</br>', 
          MapData$EstuarySites@data[i, "Name"], 
         '</br>REC#:',MapData$EstuarySites@data[i, "nzsegment"]) 
})

UnMonitoredLakeSiteLabels <- lapply(which(!MapData$LakeSites@data$Monitored), function(i) {
  paste0("Lake site:", '</br>', 
          MapData$LakeSites@data[i, "LakeName"],'</br>',"LID: ",MapData$LakeSites@data[i, "LID"], 
         '</br>REC#:',MapData$LakeSites@data[i, "nzsegment"]) 
})

MonitoredLakeSiteLabels <- lapply(which(MapData$LakeSites@data$Monitored), function(i) {
  paste0("Lake site:", '</br>', 
          MapData$LakeSites@data[i, "LakeName"],'</br>',"LID: ",MapData$LakeSites@data[i, "LID"], 
         '</br>REC#:',MapData$LakeSites@data[i, "nzsegment"]) 
})

SubCatchmentSites <- lapply(seq(nrow(MapData$SubCatchmentSites@data)), function(i) {
  paste0("Subcatchment site: ",  
          MapData$SubCatchmentSites@data[i, "RiverName"],'</br>',MapData$SubCatchmentSites@data[i, "Reason"], 
         '</br>REC#:',MapData$SubCatchmentSites@data[i, "nzsegment"]) 
})

RiverMouthSiteLabels <- lapply(seq(nrow(MapData$RiverMouthSites@data)), function(i) {
  paste0("Rivermouth site: ",'</br>',MapData$RiverMouthSites@data[i, "River"], 
         '</br>REC#:',MapData$RiverMouthSites@data[i, "nzsegment"]) 
})

TeAoMaramaSiteLabels <- lapply(seq(nrow(MapData$TeAoMaramaSites@data)), function(i) {
  paste0("Cultural site: ",'</br>',MapData$TeAoMaramaSites@data[i, "Waterbody"],'</br>',MapData$TeAoMaramaSites@data[i, "Location.descriptor"], 
         '</br>REC#:',MapData$TeAoMaramaSites@data[i, "nzsegment"]) 
})

#Setup the map
map <- leaflet::leaflet() %>% 
  leaflet::addProviderTiles(providers$OpenStreetMap) %>%
  setView(lng=168,lat=-46.0,zoom=9)

#Add the main catchments
Catchmentlabels <- sprintf(
  "<strong>Major Catchment</strong><br/>%s ",
  MapData$MajorCatchments@data$FactSheetZ
) %>% lapply(htmltools::HTML)

MCpal <- colorFactor("Dark2", domain = MapData$MajorCatchments@data$FactSheetZ)

map <- map %>%
  addPolygons(data=MapData$MajorCatchments,
  fillOpacity = 0,
  weight = 2,
  opacity = 1,
  color = "grey",
  highlight = highlightOptions(
    weight = 5,
    color = "#666"),
  label = Catchmentlabels,
  group="Major Catchments")

#Add the point source sites
PointSourceLabels <- sprintf(
  "<strong>Point source</strong><br/>%s ",
  MapData$PointSourceSite@data$Source
) %>% lapply(htmltools::HTML)

map <- map %>%
  addMarkers(data=MapData$PointSourceSites,
                   icon= ~ icons(iconUrl = "Data/Icon_warning.png",iconAnchorX = 20, iconAnchorY = 0),  #Note the use of a subdirectory called Data to keep the icon file in. This is done to replicate the situation on the Shiny App so that I can simply copy the map script directly over.
                   label = PointSourceLabels,
                   #color = "black",
                   #fillOpacity = 0.5,
                   group="Point Sources")

#Add the groundwater zones
GroundwaterLabels <- sprintf(
  "<strong>Groundwater Zone</strong><br/>%s ",
  MapData$GroundwaterZones@data$Groundwate
) %>% lapply(htmltools::HTML)
GWpal <- colorFactor("YlOrRd", domain = MapData$GroundwaterZones@data$OBJECTID)

map <- map %>%
  addPolygons(data=MapData$GroundwaterZones,
  fillOpacity = 0,
  weight = 2,
  opacity = 1,
  color = "grey",
  highlight = highlightOptions(
    weight = 5,
    color = "#666"),
  label = GroundwaterLabels,
  group="Groundwater Management Zones")

map <- map %>%
  addPolygons(data=MapData$DiffuseSourceAreas,
  fillOpacity = 0,
  weight = 2,
  opacity = 1,
  color = "black",
  highlight = highlightOptions(
    weight = 5,
    color = "#FFF"),
  label = ~nzsegment,
  group="Diffuse load source areas")

#Add the Physiography raster. Note the custom palette to Match the Environment Southland colours as given in https://www.arcgis.com/home/webmap/viewer.html?useExisting=1&layers=fe2093666347411d92b4d0d5f4677af7
Physpal <- colorFactor(palette=c("#ffff73","#38a800","#7a1973","#9ed7c2","#aa66cd","#ffaa00","#734c00","#002673","#00c5ff","#9c9c9c"), levels <- c(1,2,3,4,5,6,7,8,9,10),
                    na.color = "transparent")
map <- map %>%
  addRasterImage(MapData$Physiography, colors = Physpal, opacity = 1, group = "Physiographic Zones") %>%  
  addLegend(pal = Physpal, 
            values = values(MapData$Physiography),
            title = "Physiography",
            opacity = 1,
            labFormat  = labelFormat(
            transform = function(x) {
              levels(MapData$Physiography)[[1]]$Physiography[which(levels(MapData$Physiography)[[1]]$ID == x)]
            }),
            layerId = "Physiography",
            group="Physiographic Zones")

#Add the river network coloured by Water Plan Class. Note the custom palette set to match the Environment Southland choice of colours on their GIS page: http://gis.es.govt.nz/index.aspx?app=water-and-land
WPpal2 <- colorFactor(palette=c("#a4d1a4","#ffc34d","#ffff9e","#dcb496","#ff9ee9","#ff7f7f","#68a84d"), levels <- levels(MapData$RiverNetwork$WaterPlan),
                    na.color = "transparent")

map <- map %>%
  addPolylines(data = MapData$RiverNetwork, color= ~WPpal2(WaterPlan), weight = ~LineWidthPixels, label = ~WaterPlan, opacity = 1,group= "Water Plan Classes") %>%
    addLegend(pal = WPpal2, 
            values = MapData$RiverNetwork$WaterPlan,
            title = "Water Plan Classes",
            opacity = 1,
            #labFormat  = labelFormat(
            #transform = function(x) {
            #  levels(MapData$RiverNetwork$WaterPlan)[[1]]$WaterPlanClass[which(levels(MapData$RiverNetwork$WaterPlan)[[1]]$ID == x)]
            #}),
            layerId = "Water Plan Classess",
            group="Water Plan Classes")
  

map <- map %>%
  addCircleMarkers(data = MapData$TeAoMaramaSites, color = "#61ba46",fillOpacity = 0.5, label = lapply(TeAoMaramaSiteLabels, htmltools::HTML)) %>%
  addCircleMarkers(data = MapData$MeasurementSites, color = "#FF3333",fillOpacity = 0.5, label = lapply(MeasurementSiteLabels, htmltools::HTML)) %>%
  addCircleMarkers(data = MapData$LakeSites[MapData$LakeSites@data$Monitored,], color = "darkorange", fillOpacity = 0.5, label = lapply(MonitoredLakeSiteLabels, htmltools::HTML)) %>%
  addCircleMarkers(data = MapData$LakeSites[!MapData$LakeSites@data$Monitored,], color = "yellow", fillOpacity = 0.5, label = lapply(UnMonitoredLakeSiteLabels, htmltools::HTML)) %>%
  addCircleMarkers(data = MapData$EstuarySites, color = "turquoise", fillOpacity = 0.5,label = lapply(EstuarySiteLabels, htmltools::HTML)) %>%
  addCircleMarkers(data = MapData$RiverMouthSites, color = "brown", fillOpacity = 0.5,label = lapply(RiverMouthSiteLabels, htmltools::HTML)) %>%
  addCircleMarkers(data = MapData$SubCatchmentSites, color = "#0066CC", fillOpacity = 0.5,label = lapply(SubCatchmentSites, htmltools::HTML)) %>%
  
  addPolylines(data = MapData$RiverNetwork, color= "blue", weight = ~LineWidthPixels,group = "River Network",label = ~Label) %>%
  
  addLegend("topright", colors = c("#61ba46","#FF3333","darkorange","yellow","turquoise","brown","lightblue"), labels = c("Cultural","RWQ","Lake-Monitored","Lake-not monitored","Estuary","River Mouth","Subcatchment"),
            title = "Assessment point<br>locations",
            opacity = 1) %>%
  
  addLayersControl(
          overlayGroups =c("Major Catchments","Point Sources","Water Plan Classes","Physiographic Zones", "River Network", "Groundwater Management Zones","Diffuse load source areas"),
          options = layersControlOptions(collapsed=FALSE)
          ) %>%
  
  hideGroup(c("Major Catchments","Point Sources","Water Plan Classes","Groundwater Management Zones","River Network","Physiographic Zones","Diffuse load source areas")) %>%
  
  addScaleBar(position = "topleft", options = scaleBarOptions())

map

#save the mapdata as an R file so that it can be used in an RShinyApp
saveRDS(MapData,file.path(ProjectDirectory,"/R/CASM_Southland/ShinyApp/Data","SpatialData.RDS"))
saveRDS(map,file.path(ProjectDirectory,"/R/CASM_Southland/ShinyApp/Data","map.RDS"))
#Copy the icon file to the RShiny directory
file.copy(from = "Icon_warning.png", to=file.path(ProjectDirectory, "/R/CASM_Southland/ShinyApp/Data","Icon_warning.png"))
```


The tributary connection table needs to be converted to an Excel Spreadsheet.


I need to create an excel table of CASM-Nodes, CASM-Reach-Names, CASM-Reach-Locations, CASM-Reach-Areas, CASM-Reach-Exp.Coeff
```{r}


Out <- createWorkbook()

addWorksheet(Out, "River Network")

writeData(Out, sheet = "River Network", x = TributaryConnectionTable)

addWorksheet(Out, "Point Source")

writeData(Out, sheet = "Point Source", x = PointSourceTable)

addWorksheet(Out, "Water Quality Stations")

writeData(Out, sheet = "Water Quality Stations", x = MeasurementSiteTable)

addWorksheet(Out, "Assessment Points")

writeData(Out, sheet = "Assessment Points", x = AssessmentSiteTable)

addWorksheet(Out, "Diffuse Inputs")

writeData(Out, sheet = "Diffuse Inputs", x = DiffuseInputsSiteExtendedTable[,c("nzsegment","Node Name","Receiving Stream","Discharge Location (km)","Land Area (ha)","TN Export Coeff (kg/ha/yr)","TP Export Coeff (kg/ha/yr)","TN Physiographic-based attenuation scale estimate","TP Physiographic-based attenuation scale estimate","CASMBasin")])

saveWorkbook(Out, file.path(DataDirectory,"CASM-InputsV2.xlsx"), overwrite = T)
```
